import { EthereumProviderError } from "@metamask/rpc-errors";
import { COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, CommunicationWalletProviderState } from "@toruslabs/base-controllers";
import { JRPCRequest, RequestArguments } from "@toruslabs/openlogin-jrpc";
import type { Duplex } from "readable-stream";

import BaseProvider from "./baseProvider";
import { BUTTON_POSITION, CommunicationProviderState, LOGIN_PROVIDER_TYPE, ProviderOptions, UnValidatedJsonRpcRequest } from "./interfaces";
import log from "./loglevel";
import messages from "./messages";
import PopupHandler from "./PopupHandler";

/**
 * @param connectionStream - A Node.js duplex stream
 * @param  opts - An options bag
 */
class CommunicationProvider extends BaseProvider<CommunicationProviderState> {
  protected static defaultState: CommunicationProviderState = {
    buttonPosition: "bottom-left",
    currentLoginProvider: null,
    isIFrameFullScreen: false,
    hasEmittedConnection: false,

    widgetVisibility: false,
    initialized: false,
    isLoggedIn: false,
    isPermanentlyDisconnected: false,
    isConnected: false,
  };

  tryWindowHandle: (payload: UnValidatedJsonRpcRequest | UnValidatedJsonRpcRequest[], cb: (...args: unknown[]) => void) => void;

  public windowRefs: Map<string, PopupHandler>;

  public iframeUrl: string;

  private iframe: HTMLIFrameElement;

  constructor(
    connectionStream: Duplex,
    { maxEventListeners = 100, jsonRpcStreamName = "provider" }: ProviderOptions,
    state: Partial<CommunicationProviderState>
  ) {
    super(connectionStream, { maxEventListeners, jsonRpcStreamName });

    // private state
    this.state = {
      ...CommunicationProvider.defaultState,
      ...state,
    };

    // public state
    this.iframeUrl = "";
    this.windowRefs = new Map();

    // setup own event listeners

    // EIP-1193 connect
    this.on("connect", () => {
      this.state.isConnected = true;
    });

    const notificationHandler = (payload: RequestArguments<unknown>) => {
      const { method, params } = payload;
      // create_window should never come here..
      // we either pre-open from embed.
      // if it's blocked, we communicate down that it's blocked and we show full screen iframe and open from iframe
      if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {
        const { isFullScreen, rid } = params as Record<string, unknown>;
        this.displayIframe({ isFull: isFullScreen as boolean, rid: rid as string });
      } else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {
        this.handleCloseWindow(params as Record<string, unknown>);
      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {
        const { currentLoginProvider } = params as Record<string, unknown>;
        this.state.isLoggedIn = true;
        this.state.currentLoginProvider = currentLoginProvider as LOGIN_PROVIDER_TYPE;
      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {
        this.state.isLoggedIn = false;
        this.state.currentLoginProvider = null;
        this.displayIframe();
      }
    };

    this.jsonRpcConnectionEvents.on("notification", notificationHandler);
  }

  get isLoggedIn(): boolean {
    return this.state.isLoggedIn;
  }

  get isIFrameFullScreen(): boolean {
    return this.state.isIFrameFullScreen;
  }

  /**
   * Returns whether the inPage provider is connected to Torus.
   */
  isConnected(): boolean {
    return this.state.isConnected;
  }

  async initializeState(params: Record<string, unknown>): Promise<void> {
    try {
      const { torusUrl, torusIframe } = params;
      this.iframeUrl = torusUrl as string;
      this.iframe = torusIframe as HTMLIFrameElement;
      this.iframe.addEventListener("load", () => {
        // only do this if iframe is not full screen
        if (!this.state.isIFrameFullScreen) this.displayIframe();
      });
      const { currentLoginProvider, isLoggedIn } = (await this.request({
        method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,
        params: [],
      })) as CommunicationWalletProviderState;

      // indicate that we've connected, for EIP-1193 compliance
      this.handleConnect(currentLoginProvider, isLoggedIn);
    } catch (error) {
      log.error("Web3Auth: Failed to get initial state. Please report this bug.", error);
    } finally {
      log.info("initialized communication state");
      this.state.initialized = true;
      this.emit("_initialized");
    }
  }

  hideTorusButton(): void {
    this.state.widgetVisibility = false;
    this.displayIframe();
  }

  showTorusButton(): void {
    this.state.widgetVisibility = true;
    this.displayIframe();
  }

  public displayIframe({ isFull = false, rid = "" }: { isFull?: boolean; rid?: string } = {}): void {
    const style: Partial<CSSStyleDeclaration> = {};
    // set phase
    if (!isFull) {
      style.display = this.state.widgetVisibility ? "block" : "none";
      style.height = "70px";
      style.width = "70px";
      switch (this.state.buttonPosition) {
        case BUTTON_POSITION.TOP_LEFT:
          style.top = "0px";
          style.left = "0px";
          style.right = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.TOP_RIGHT:
          style.top = "0px";
          style.right = "0px";
          style.left = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_RIGHT:
          style.bottom = "0px";
          style.right = "0px";
          style.top = "auto";
          style.left = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_LEFT:
        default:
          style.bottom = "0px";
          style.left = "0px";
          style.top = "auto";
          style.right = "auto";
          break;
      }
    } else {
      style.display = "block";
      style.width = "100%";
      style.height = "100%";
      style.top = "0px";
      style.right = "0px";
      style.left = "0px";
      style.bottom = "0px";
    }
    Object.assign(this.iframe.style, style);
    this.state.isIFrameFullScreen = isFull;
    this.request<{ isIFrameFullScreen: boolean; rid?: string }, void>({
      method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,
      params: { isIFrameFullScreen: isFull, rid },
    });
  }

  public async handleWindow(windowId: string, { url, target, features }: { url?: string; target?: string; features?: string } = {}): Promise<void> {
    const finalUrl = new URL(url || `${this.iframeUrl}/redirect?windowId=${windowId}`);
    const handledWindow = new PopupHandler({ url: finalUrl, target, features });
    await handledWindow.open();
    if (!handledWindow.window) {
      this.displayIframe({ isFull: true });
      this.request<{ windowId: string; finalUrl: string }, void>({
        method: COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED,
        params: { windowId, finalUrl: finalUrl.href },
      });
      return;
    }
    // Add to collection only if window is opened
    this.windowRefs.set(windowId, handledWindow);
    // We tell the iframe that the window has been successfully opened
    this.request<{ windowId: string }, void>({
      method: COMMUNICATION_JRPC_METHODS.OPENED_WINDOW,
      params: { windowId },
    });
    handledWindow.once("close", () => {
      // user closed the window
      this.windowRefs.delete(windowId);
      this.request<{ windowId: string }, void>({
        method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,
        params: { windowId },
      });
    });
  }

  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  protected rpcRequest(payload: UnValidatedJsonRpcRequest | UnValidatedJsonRpcRequest[], callback: (...args: unknown[]) => void): void {
    const cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
    }
    this.rpcEngine.handle(_payload as JRPCRequest<unknown>, cb);
  }

  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param currentLoginProvider - The login Provider
   * emits TorusInpageProvider#connect
   */
  protected handleConnect(currentLoginProvider: string, isLoggedIn: boolean): void {
    if (!this.state.isConnected) {
      this.state.isConnected = true;
      this.emit("connect", { currentLoginProvider, isLoggedIn });
      log.debug(messages.info.connected(currentLoginProvider));
    }
  }

  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  protected handleDisconnect(isRecoverable: boolean, errorMessage?: string): void {
    if (this.state.isConnected || (!this.state.isPermanentlyDisconnected && !isRecoverable)) {
      this.state.isConnected = false;

      let error: Error;
      if (isRecoverable) {
        error = new EthereumProviderError(
          1013, // Try again later
          errorMessage || messages.errors.disconnected()
        );
        log.debug(error);
      } else {
        error = new EthereumProviderError(
          1011, // Internal error
          errorMessage || messages.errors.permanentlyDisconnected()
        );
        log.error(error);
        this.state.currentLoginProvider = null;
        this.state.isLoggedIn = false;
        this.state.widgetVisibility = false;
        this.state.isIFrameFullScreen = false;
        this.state.isPermanentlyDisconnected = true;
      }

      this.emit("disconnect", error);
    }
  }

  private handleCloseWindow(params: { windowId?: string }): void {
    const { windowId } = params;
    if (this.windowRefs.has(windowId)) {
      this.windowRefs.get(windowId).close();
      this.windowRefs.delete(windowId);
    }
  }
}

export default CommunicationProvider;
