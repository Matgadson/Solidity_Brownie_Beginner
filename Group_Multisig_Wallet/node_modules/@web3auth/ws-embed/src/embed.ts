import {
  COMMUNICATION_JRPC_METHODS,
  FEATURES_CONFIRM_WINDOW,
  FEATURES_PROVIDER_CHANGE_WINDOW,
  getPopupFeatures,
  randomId,
} from "@toruslabs/base-controllers";
import { METHOD_TYPES, METHOD_TYPES_TYPE } from "@toruslabs/ethereum-controllers";
import { BasePostMessageStream, getRpcPromiseCallback, JRPCRequest } from "@toruslabs/openlogin-jrpc";
import { Duplex } from "readable-stream";

import CommunicationProvider from "./communicationProvider";
import { htmlToElement } from "./embedUtils";
import TorusInPageProvider from "./inPageProvider";
import {
  BUTTON_POSITION,
  BUTTON_POSITION_TYPE,
  CtorArgs,
  LOGIN_PROVIDER_TYPE,
  UnValidatedJsonRpcRequest,
  UserInfo,
  WalletUrlConfig,
  WS_EMBED_BUILD_ENV,
  WS_EMBED_BUILD_ENV_TYPE,
  WsEmbedParams,
} from "./interfaces";
import log from "./loglevel";
import getSiteMetadata from "./siteMetadata";

const WALLET_URLS_DEFAULT: Record<WS_EMBED_BUILD_ENV_TYPE, WalletUrlConfig> = {
  [WS_EMBED_BUILD_ENV.TESTING]: {
    url: "https://lrc-wallet.web3auth.io",
    logLevel: "debug",
  },
  [WS_EMBED_BUILD_ENV.DEVELOPMENT]: {
    url: "http://localhost:4050",
    logLevel: "debug",
  },
  [WS_EMBED_BUILD_ENV.PRODUCTION]: {
    url: "https://wallet.web3auth.io",
    logLevel: "error",
  },
};

// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267
(async function preLoadIframe() {
  try {
    if (typeof document === "undefined") return;
    const torusIframeHtml = document.createElement("link");
    const { url: torusUrl } = WALLET_URLS_DEFAULT.production;
    torusIframeHtml.href = `${torusUrl}/frame`;
    torusIframeHtml.crossOrigin = "anonymous";
    torusIframeHtml.type = "text/html";
    torusIframeHtml.rel = "prefetch";
    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
      if (torusIframeHtml.relList.supports("prefetch")) {
        document.head.appendChild(torusIframeHtml);
      }
    }
  } catch (error) {
    log.warn(error);
  }
})();

export const COMMUNICATION_UNSAFE_METHODS = new Set([COMMUNICATION_JRPC_METHODS.SET_PROVIDER]) as Set<
  Partial<(typeof COMMUNICATION_JRPC_METHODS)[keyof typeof COMMUNICATION_JRPC_METHODS]>
>;

export const PROVIDER_UNSAFE_METHODS = new Set([
  METHOD_TYPES.ETH_DECRYPT,
  METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY,
  METHOD_TYPES.ETH_SIGN,
  METHOD_TYPES.ETH_SIGN_TYPED_DATA,
  METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3,
  METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4,
  METHOD_TYPES.PERSONAL_SIGN,
  METHOD_TYPES.ETH_TRANSACTION,
  METHOD_TYPES.ADD_CHAIN,
  METHOD_TYPES.SWITCH_CHAIN,
]) as Set<Partial<METHOD_TYPES_TYPE>>;

class WsEmbed {
  isInitialized: boolean;

  modalZIndex: number;

  provider: TorusInPageProvider;

  widgetVisibility: boolean;

  communicationProvider: CommunicationProvider;

  buttonPosition: BUTTON_POSITION_TYPE;

  private walletIframe: HTMLIFrameElement;

  constructor({ modalZIndex = 99999 }: CtorArgs = {}) {
    this.isInitialized = false; // init done
    this.modalZIndex = modalZIndex;
  }

  async init({
    buildEnv = WS_EMBED_BUILD_ENV.PRODUCTION,
    enableLogging = false,
    chainConfig,
    showWidgetButton: showTorusButton = false,
    buttonPosition = BUTTON_POSITION.BOTTOM_LEFT,
    walletUrls,
  }: WsEmbedParams = {}): Promise<void> {
    if (this.isInitialized) throw new Error("Already initialized");
    const { url: torusUrl, logLevel } =
      walletUrls && walletUrls[buildEnv] ? { ...WALLET_URLS_DEFAULT[buildEnv], ...walletUrls[buildEnv] } : WALLET_URLS_DEFAULT[buildEnv];
    log.info(torusUrl, "url loaded");
    log.setDefaultLevel(logLevel);
    if (enableLogging) log.enableAll();
    else log.disableAll();

    const torusIframeUrl = new URL(torusUrl);
    if (torusIframeUrl.pathname.endsWith("/")) torusIframeUrl.pathname += "frame";
    else torusIframeUrl.pathname += "/frame";

    const hashParams = new URLSearchParams();
    hashParams.append("origin", window.location.origin);

    torusIframeUrl.hash = hashParams.toString();
    // sandbox="allow-popups allow-scripts allow-same-origin"
    // Iframe code
    this.walletIframe = htmlToElement<HTMLIFrameElement>(
      `<iframe
        id="walletIframe"
        class="walletIframe"
        sandbox="allow-popups allow-scripts allow-same-origin allow-forms"
        src="${torusIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}"
      ></iframe>`
    );

    this.buttonPosition = buttonPosition;

    return new Promise<void>((resolve, reject) => {
      try {
        window.document.body.appendChild(this.walletIframe);
        this.walletIframe.addEventListener("load", async () => {
          const dappMetadata = await getSiteMetadata();
          // send init params here
          this.walletIframe.contentWindow.postMessage(
            {
              buttonPosition,
              chainConfig,
              dappMetadata,
              enableLogging,
            },
            torusIframeUrl.origin
          );
          await this.setupWeb3({
            torusUrl,
          });
          // if (showTorusButton) this.showTorusButton();
          // else this.hideTorusButton();
          this.widgetVisibility = showTorusButton;
          this.isInitialized = true;
          resolve();
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  async login(params: { loginProvider?: LOGIN_PROVIDER_TYPE; login_hint?: string } = {}): Promise<string[]> {
    if (!this.isInitialized) throw new Error("Call init() first");
    try {
      if (!params.loginProvider) {
        this.communicationProvider.displayIframe({ isFull: true });
      }

      // If user is already logged in, we assume they have given access to the website
      const res = await new Promise((resolve, reject) => {
        // We use this method because we want to update inPage provider state with account info
        this.provider.rpcRequest(
          { method: "eth_requestAccounts", params: [params.loginProvider, params.login_hint] },
          getRpcPromiseCallback(resolve as (value?: unknown) => void, reject) as (...args: unknown[]) => void
        );
      });
      log.info("check: res", res);

      if (Array.isArray(res) && res.length > 0) {
        if (this.widgetVisibility) this.showTorusButton();
        return res;
      }
      // This would never happen, but just in case
      throw new Error("Login failed");
    } catch (error) {
      log.error("login failed", error);
      throw error;
    } finally {
      this.communicationProvider.displayIframe({ isFull: false });
    }
  }

  async logout(): Promise<void> {
    if (!this.communicationProvider.isLoggedIn) throw new Error("Not logged in");

    await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.LOGOUT,
      params: [],
    });

    this.hideTorusButton();
  }

  async cleanUp(): Promise<void> {
    if (this.communicationProvider.isLoggedIn) {
      await this.logout();
    }
    this.clearInit();
  }

  clearInit(): void {
    function isElement(element: unknown) {
      return element instanceof Element || element instanceof Document;
    }
    if (isElement(this.walletIframe) && window.document.body.contains(this.walletIframe)) {
      this.walletIframe.remove();
      this.walletIframe = undefined;
    }
    this.isInitialized = false;
  }

  hideTorusButton(): void {
    this.communicationProvider.hideTorusButton();
  }

  showTorusButton(): void {
    this.communicationProvider.showTorusButton();
  }

  async getUserInfo(): Promise<UserInfo> {
    const userInfoResponse = await this.communicationProvider.request<[], UserInfo>({
      method: COMMUNICATION_JRPC_METHODS.USER_INFO,
      params: [],
    });
    return userInfoResponse as UserInfo;
  }

  async showWalletConnectScanner(): Promise<void> {
    this.communicationProvider.displayIframe({ isFull: true });
    await this.communicationProvider.request<[], boolean>({
      method: COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT,
      params: [],
    });
  }

  async showWalletUi(): Promise<void> {
    this.communicationProvider.displayIframe({ isFull: true });
    await this.communicationProvider.request<[], boolean>({
      method: COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI,
      params: [],
    });
  }

  async showCheckout(): Promise<void> {
    this.communicationProvider.displayIframe({ isFull: true });
    await this.communicationProvider.request<[], boolean>({
      method: COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT,
      params: [],
    });
  }

  private async setupWeb3(providerParams: { torusUrl: string }): Promise<void> {
    log.info("setupWeb3 running");
    // setup background connection
    const providerStream = new BasePostMessageStream({
      name: "embed_torus",
      target: "iframe_torus",
      targetWindow: this.walletIframe.contentWindow,
      targetOrigin: providerParams.torusUrl,
    });

    // We create another LocalMessageDuplexStream for communication between dapp <> iframe
    const communicationStream = new BasePostMessageStream({
      name: "embed_communication",
      target: "iframe_communication",
      targetWindow: this.walletIframe.contentWindow,
      targetOrigin: providerParams.torusUrl,
    });

    // compose the inPage provider
    const inPageProvider = new TorusInPageProvider(providerStream as unknown as Duplex, {});
    const communicationProvider = new CommunicationProvider(communicationStream as unknown as Duplex, {}, { buttonPosition: this.buttonPosition });

    inPageProvider.tryWindowHandle = (payload: UnValidatedJsonRpcRequest | UnValidatedJsonRpcRequest[], cb: (...args: unknown[]) => void) => {
      const _payload = payload;
      if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.has(_payload.method as METHOD_TYPES_TYPE)) {
        const windowId = randomId();
        communicationProvider.handleWindow(windowId, {
          target: "_blank",
          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW),
        });
        // for inPageProvider methods sending windowId in request instead of params
        // as params might be positional.
        _payload.windowId = windowId;
      }
      inPageProvider.rpcEngine.handle(_payload as JRPCRequest<unknown>[], cb);
    };

    communicationProvider.tryWindowHandle = ((payload: UnValidatedJsonRpcRequest, cb: (...args: unknown[]) => void) => {
      const _payload = payload;
      if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.has(_payload.method)) {
        const windowId = randomId();
        communicationProvider.handleWindow(windowId, {
          target: "_blank",
          features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW), // todo: are these features generic for all
        });
        // for communication methods sending window id in jrpc req params
        (_payload.params as Record<string, unknown>).windowId = windowId;
      }
      communicationProvider.rpcEngine.handle(_payload as JRPCRequest<unknown>, cb);
    }) as (payload: UnValidatedJsonRpcRequest | UnValidatedJsonRpcRequest[], cb: (...args: unknown[]) => void) => void;

    // detect eth_requestAccounts and pipe to enable for now
    const detectAccountRequestPrototypeModifier = (m: keyof TorusInPageProvider) => {
      const originalMethod = inPageProvider[m];
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const self = this;

      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      inPageProvider[m] = function providerFunc(request, cb) {
        const { method, params = [] } = request;
        if (method === "eth_requestAccounts") {
          if (!cb) return self.login({ loginProvider: params[0] });
          self
            .login({ loginProvider: params[0] })
            // eslint-disable-next-line promise/no-callback-in-promise
            .then((res) => cb(null, res))
            // eslint-disable-next-line promise/no-callback-in-promise
            .catch((err) => cb(err));
        }
        return (originalMethod as (request: unknown, cb: unknown) => void).apply(this, [request, cb]);
      };
    };

    // Detects call to eth_requestAccounts in request & sendAsync and passes to login
    detectAccountRequestPrototypeModifier("request");
    detectAccountRequestPrototypeModifier("sendAsync");
    detectAccountRequestPrototypeModifier("send");

    const proxiedInPageProvider = new Proxy(inPageProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true,
    });

    const proxiedCommunicationProvider = new Proxy(communicationProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true,
    });

    this.provider = proxiedInPageProvider;
    this.communicationProvider = proxiedCommunicationProvider;

    log.info("test setupWeb3 ");
    await Promise.all([
      inPageProvider.initializeState(),
      communicationProvider.initializeState({
        ...providerParams,
        torusIframe: this.walletIframe,
      }),
    ]);
    log.debug("WsEmbed - injected provider");
  }
}

export default WsEmbed;
