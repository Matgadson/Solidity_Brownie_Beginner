import { BasePreferencesController, CustomNft, CustomToken, IPreferencesController, PreferencesConfig, PreferencesState, UserInfo } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import PollingBlockTracker from "../Block/PollingBlockTracker";
import KeyringController from "../Keyring/KeyringController";
import NetworkController from "../Network/NetworkController";
import type { AddChainMessageParams, CustomNetworkPayload, CustomNftInfo, CustomTokenInfo, ExtendedAddressPreferences, TransactionPayload } from "../utils/interfaces";
interface IPreferencesControllerOptions {
    config?: Partial<PreferencesConfig> & Pick<PreferencesConfig, "api" | "commonApiHost" | "signInPrefix">;
    state?: Partial<PreferencesState<ExtendedAddressPreferences>>;
    provider: SafeEventEmitterProvider;
    blockTracker?: PollingBlockTracker;
    signAuthMessage?: KeyringController["signAuthMessage"];
    getProviderConfig?: NetworkController["getProviderConfig"];
    setProviderConfig?: NetworkController["setProviderConfig"];
}
export default class PreferencesController extends BasePreferencesController<ExtendedAddressPreferences, PreferencesConfig, PreferencesState<ExtendedAddressPreferences>> implements IPreferencesController<ExtendedAddressPreferences, PreferencesConfig, PreferencesState<ExtendedAddressPreferences>> {
    private _handle?;
    private _mutex;
    private getProviderConfig;
    private setProviderConfig;
    private provider;
    private blockTracker;
    constructor({ config, state, provider, blockTracker, signAuthMessage, getProviderConfig, setProviderConfig }: IPreferencesControllerOptions);
    poll(interval?: number): Promise<void>;
    initPreferences(params: {
        address: string;
        jwtToken?: string;
        calledFromEmbed?: boolean;
        userInfo?: UserInfo;
        rehydrate?: boolean;
        locale?: string;
        type?: string;
        signatures?: string[];
        network?: string;
        web3AuthClientId?: string;
    }): Promise<void>;
    getSelectedAddress(): string;
    sync(address: string): Promise<boolean>;
    patchNewTx(tx: TransactionPayload, address: string): Promise<void>;
    recalculatePastTx(address?: string): void;
    refetchEtherscanTx(address?: string): Promise<void>;
    fetchEtherscanTx<T>(parameters: {
        selectedAddress: string;
        selectedNetwork: string;
    }): Promise<T[]>;
    getEtherScanTokens(address: string, chainId: string): Promise<CustomTokenInfo[]>;
    getSimpleHashNfts(address: string, chainId: string): Promise<CustomNftInfo[]>;
    getCustomTokens(address?: string): CustomToken[];
    getCustomNfts(address?: string): CustomNft[];
    isChainIdSupported(address: string, chainId: string): boolean;
    addChain(network: AddChainMessageParams): Promise<void>;
    switchChain(data: {
        chainId: string;
    }): void;
    addCustomNetwork({ type, network }: {
        type: string;
        network: CustomNetworkPayload;
    }): Promise<number>;
    deleteCustomNetwork(id: number): Promise<boolean>;
    editCustomNetwork({ network, id }: {
        network: CustomNetworkPayload;
        id: number | null;
    }): Promise<boolean>;
    private getChainOptions;
    private calculatePastTx;
    private cancelTxCalculate;
}
export {};
