import { createFetchMiddleware, ProviderConfig } from "@toruslabs/base-controllers";
import {
  JRPCEngineEndCallback,
  JRPCEngineNextCallback,
  JRPCMiddleware,
  JRPCRequest,
  JRPCResponse,
  mergeMiddleware,
  providerFromMiddleware,
} from "@toruslabs/openlogin-jrpc";

import PollingBlockTracker from "../Block/PollingBlockTracker";
import { EthereumNetworkConfig } from "../utils/interfaces";

export function createChainIdMiddleware(chainId: string): JRPCMiddleware<unknown, string> {
  return (req: JRPCRequest<unknown>, res: JRPCResponse<string>, next: JRPCEngineNextCallback, end: JRPCEngineEndCallback) => {
    if (req.method === "eth_chainId") {
      res.result = chainId;
      return end();
    }
    if (req.method === "net_version") {
      // convert to decimal
      res.result = Number.parseInt(chainId, 16).toString(10);
      return end();
    }
    return next();
  };
}

export function createProviderConfigMiddleware(providerConfig: ProviderConfig): JRPCMiddleware<unknown, ProviderConfig> {
  return (req: JRPCRequest<unknown>, res: JRPCResponse<ProviderConfig>, next: JRPCEngineNextCallback, end: JRPCEngineEndCallback) => {
    if (req.method === "eth_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}

export function createJsonRpcClient(
  providerConfig: ProviderConfig,
  networkConfig: EthereumNetworkConfig
): {
  networkMiddleware: JRPCMiddleware<unknown, unknown>;
  blockTracker: PollingBlockTracker;
} {
  const { chainId, rpcTarget } = providerConfig;
  const fetchMiddleware = createFetchMiddleware({ rpcTarget });
  const blockProvider = providerFromMiddleware(fetchMiddleware as JRPCMiddleware<unknown, unknown>);
  const blockTracker = new PollingBlockTracker({ config: { ...networkConfig, provider: blockProvider }, state: {} });

  const networkMiddleware = mergeMiddleware([
    createChainIdMiddleware(chainId) as JRPCMiddleware<unknown, unknown>,
    createProviderConfigMiddleware(providerConfig) as JRPCMiddleware<unknown, unknown>,
    // No need for the following middlewares for web because all browser sessions are quite short lived and each session is limited to scope of a window/tab
    // createBlockRefRewriteMiddleware({ blockTracker }),
    // createBlockCacheMiddleware({ blockTracker }),
    // createInflightCacheMiddleware(),
    // createBlockTrackerInspectorMiddleware({ blockTracker }),
    fetchMiddleware as JRPCMiddleware<unknown, unknown>,
  ]);
  return { networkMiddleware, blockTracker };
}
