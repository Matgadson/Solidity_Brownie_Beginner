import { SignTypedDataVersion } from "@metamask/eth-sig-util";
import { InPageWalletProviderState, PROVIDER_JRPC_METHODS } from "@toruslabs/base-controllers";
import {
  createAsyncMiddleware,
  createScaffoldMiddleware,
  JRPCEngineEndCallback,
  JRPCEngineNextCallback,
  JRPCMiddleware,
  JRPCRequest,
  JRPCResponse,
  mergeMiddleware,
} from "@toruslabs/openlogin-jrpc";

import { METHOD_TYPES, TRANSACTION_ENVELOPE_TYPES } from "../utils/constants";
import {
  AddChainMessageParams,
  BlockParams,
  EncryptionPublicKeyParams,
  EthereumTransactionMeta,
  MessageParams,
  SwitchChainMessageParams,
  TransactionParams,
  TransactionRPCMeta,
  TypedMessageParams,
  UserRequestApprovalParams,
} from "../utils/interfaces";

export interface IProviderHandlers {
  version: string;
  requestAccounts?: (req: JRPCRequest<string[]>) => Promise<string[]>;
  getAccounts: (req: JRPCRequest<string[]>) => Promise<string[]>;

  // All operations which open popup window or modal should operate with a windowId parameter
  processTransaction?: (txParams: TransactionParams, req: JRPCRequest<TransactionParams> & UserRequestApprovalParams) => Promise<string>;

  processEthSignMessage?: (msgParams: MessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
  processTypedMessage?: (msgParams: TypedMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
  processTypedMessageV3?: (msgParams: TypedMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
  processTypedMessageV4?: (msgParams: TypedMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
  processPersonalMessage?: (msgParams: MessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;

  processEncryptionPublicKey?: (msgParams: EncryptionPublicKeyParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;
  processDecryptMessage?: (msgParams: MessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;

  processSwitchEthereumChain?: (msgParams: SwitchChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;

  processAddEthereumChain?: (msgParams: AddChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams) => Promise<string>;

  getPendingNonce?: (
    nonceParams: { address: string; blockReference: string },
    req: JRPCRequest<{ address: string; blockReference: string }>
  ) => Promise<string>;
  getPendingTransactionByHash?: (hash: string, req: JRPCRequest<string>) => Promise<EthereumTransactionMeta>;

  getProviderState: (
    req: JRPCRequest<[]>,
    res: JRPCResponse<InPageWalletProviderState>,
    next: JRPCEngineNextCallback,
    end: JRPCEngineEndCallback
  ) => void;
}

export function createGetAccountsMiddleware({ getAccounts }: { getAccounts: IProviderHandlers["getAccounts"] }): JRPCMiddleware<never, string[]> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.GET_ACCOUNTS) return next();

    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided");

    const accounts = await getAccounts(request);
    response.result = accounts;
  });
}

export function createProcessTransactionMiddleware({
  processTransaction,
}: {
  processTransaction: IProviderHandlers["processTransaction"];
}): JRPCMiddleware<TransactionParams, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.ETH_TRANSACTION) return next();

    if (!processTransaction) throw new Error("WalletMiddleware - opts.processTransaction not provided");

    response.result = await processTransaction(request.params, request);
  });
}

export function createProcessEthSignMessage({
  processEthSignMessage,
}: {
  processEthSignMessage: IProviderHandlers["processEthSignMessage"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.ETH_SIGN) return next();

    if (!processEthSignMessage) throw new Error("WalletMiddleware - opts.processEthSignMessage not provided");
    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: MessageParams = request.params as MessageParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, message]`);

      const params = request.params as [string, string];
      const address = params[0];
      const message = params[1];

      msgParams = {
        from: address,
        data: message,
      };
    }

    response.result = await processEthSignMessage(msgParams, request);
  });
}

export function createProcessTypedMessage({
  processTypedMessage,
}: {
  processTypedMessage: IProviderHandlers["processTypedMessage"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA) return next();

    if (!processTypedMessage) throw new Error("WalletMiddleware - opts.processTypedMessage not  provided");
    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: TypedMessageParams = request.params as TypedMessageParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [typedData, address]`);

      const params = request.params as [Record<string, unknown>[], string];
      const message = params[0];
      const address = params[1];

      msgParams = {
        from: address,
        data: message,
        version: SignTypedDataVersion.V1,
      };
    }

    response.result = await processTypedMessage(msgParams, request);
  });
}

export function createProcessTypedMessageV3({
  processTypedMessageV3,
}: {
  processTypedMessageV3: IProviderHandlers["processTypedMessageV3"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3) return next();

    if (!processTypedMessageV3) throw new Error("WalletMiddleware - opts.processTypedMessageV3 is not provided");
    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: TypedMessageParams = request.params as TypedMessageParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);

      const params = request.params as [string, string];
      const address = params[0];
      const message = JSON.parse(params[1]);

      msgParams = {
        from: address,
        data: message,
        version: SignTypedDataVersion.V3,
      };
    }

    response.result = await processTypedMessageV3(msgParams, request);
  });
}

export function createProcessTypedMessageV4({
  processTypedMessageV4,
}: {
  processTypedMessageV4: IProviderHandlers["processTypedMessageV4"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4) return next();

    if (!processTypedMessageV4) throw new Error("WalletMiddleware - opts.processTypedMessageV4 is not provided");
    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: TypedMessageParams = request.params as TypedMessageParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);

      const params = request.params as [string, string];
      const address = params[0];
      const message = JSON.parse(params[1]);

      msgParams = {
        from: address,
        data: message,
        version: SignTypedDataVersion.V4,
      };
    }

    response.result = await processTypedMessageV4(msgParams, request);
  });
}

export function createProcessPersonalMessage({
  processPersonalMessage,
}: {
  processPersonalMessage: IProviderHandlers["processPersonalMessage"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.PERSONAL_SIGN) return next();

    if (!processPersonalMessage) throw new Error("WalletMiddleware - opts.processPersonalMessage is not provided");
    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: MessageParams = request.params as MessageParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);

      const params = request.params as [string, string];
      const message = params[0];
      const address = params[1];

      msgParams = {
        from: address,
        data: message,
      };
    }

    response.result = await processPersonalMessage(msgParams, request);
  });
}

export function createPendingNonceMiddleware({
  getPendingNonce,
}: {
  getPendingNonce: IProviderHandlers["getPendingNonce"];
}): JRPCMiddleware<{ address: string; blockReference: BlockParams }, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { params, method } = request;
    if (method !== METHOD_TYPES.ETH_GET_TRANSACTION_COUNT) return next();

    const { blockReference } = params;
    if (blockReference !== "pending") return next();
    response.result = await getPendingNonce(params, request);
  });
}

export function formatTxMetaForRpcResult(txMeta: EthereumTransactionMeta): TransactionRPCMeta {
  const { r, s, v, txReceipt, transaction, transactionHash, accessList } = txMeta;
  const { to, data, nonce, gas, from, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas } = transaction;

  const formattedTxMeta: TransactionRPCMeta = {
    v,
    r,
    s,
    to,
    gas,
    from,
    hash: transactionHash,
    nonce,
    input: data || "0x",
    value: value || "0x0",
    accessList: accessList || null,
    blockHash: txReceipt?.blockHash || null,
    blockNumber: txReceipt?.blockNumber || null,
    transactionIndex: txReceipt?.transactionIndex || null,
    type: null,
  };

  if (maxFeePerGas && maxPriorityFeePerGas) {
    formattedTxMeta.maxFeePerGas = maxFeePerGas;
    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;
    formattedTxMeta.type = TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
  } else {
    formattedTxMeta.gasPrice = gasPrice;
    formattedTxMeta.type = TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }

  return formattedTxMeta;
}

export function createPendingTxMiddleware({
  getPendingTransactionByHash,
}: {
  getPendingTransactionByHash: IProviderHandlers["getPendingTransactionByHash"];
}): JRPCMiddleware<string, TransactionRPCMeta> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { params, method } = request;
    if (method !== METHOD_TYPES.ETH_GET_TRANSACTION_BY_HASH) return next();

    if (!getPendingTransactionByHash) throw new Error("WalletMiddleware - opts.getPendingTransactionByHash not provided");

    const txMeta = await getPendingTransactionByHash(params, request);
    if (!txMeta) {
      return next();
    }
    response.result = formatTxMetaForRpcResult(txMeta);
    return undefined;
  });
}

export function createProcessEncryptionPublicKeyMiddleware({
  processEncryptionPublicKey,
}: {
  processEncryptionPublicKey: IProviderHandlers["processEncryptionPublicKey"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY) return next();

    if (!processEncryptionPublicKey) throw new Error("WalletMiddleware - opts.processEncryptionPublicKey not provided");

    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: EncryptionPublicKeyParams = request.params as EncryptionPublicKeyParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address]`);

      const [address] = request.params as [string];
      msgParams = { data: address, from: address };
    }

    response.result = await processEncryptionPublicKey(msgParams, request);
  });
}

export function createProcessDecryptMessageMiddleware({
  processDecryptMessage,
}: {
  processDecryptMessage: IProviderHandlers["processDecryptMessage"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.ETH_DECRYPT) return next();

    if (!processDecryptMessage) throw new Error("WalletMiddleware - opts.processDecryptMessage not provided");

    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: MessageParams = request.params as MessageParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);

      const [message, address] = request.params as [string, string];
      msgParams = { data: message, from: address };
    }

    response.result = await processDecryptMessage(msgParams, request);
  });
}

export function createProcessSwitchEthereumChain({
  processSwitchEthereumChain,
}: {
  processSwitchEthereumChain: IProviderHandlers["processSwitchEthereumChain"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.SWITCH_CHAIN) return next();

    if (!processSwitchEthereumChain) throw new Error("WalletMiddleware - opts.processSwitchEthereumChain not provided");
    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: SwitchChainMessageParams = request.params as SwitchChainMessageParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);

      const [message] = request.params as [SwitchChainMessageParams];
      msgParams = message;
    }

    response.result = await processSwitchEthereumChain(msgParams, request);
  });
}

export function createProcessAddEthereumChain({
  processAddEthereumChain,
}: {
  processAddEthereumChain: IProviderHandlers["processAddEthereumChain"];
}): JRPCMiddleware<unknown, string> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== METHOD_TYPES.ADD_CHAIN) return next();

    if (!processAddEthereumChain) throw new Error("WalletMiddleware - opts.processAddEthereumChain not provided");
    if (!request?.params) throw new Error("WalletMiddleware - missing params");

    let msgParams: AddChainMessageParams = request.params as AddChainMessageParams;

    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);

      const [message] = request.params as [AddChainMessageParams];
      msgParams = message;
    }

    response.result = await processAddEthereumChain(msgParams, request);
  });
}

export function createRequestAccountsMiddleware({
  requestAccounts,
}: {
  requestAccounts: IProviderHandlers["requestAccounts"];
}): JRPCMiddleware<string[], unknown> {
  return createAsyncMiddleware(async (request, response, next) => {
    const { method } = request;
    if (method !== "eth_requestAccounts") return next();

    if (!requestAccounts) throw new Error("WalletMiddleware - opts.requestAccounts not provided");
    // This calls the UI login function
    const accounts = await requestAccounts(request);
    response.result = accounts;
    return undefined;
  });
}

export function createEthereumMiddleware(providerHandlers: IProviderHandlers): JRPCMiddleware<unknown, unknown> {
  const {
    requestAccounts,
    getAccounts,
    processTransaction,
    processEthSignMessage,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    getPendingNonce,
    getPendingTransactionByHash,
    processEncryptionPublicKey,
    processDecryptMessage,
    processSwitchEthereumChain,
    processAddEthereumChain,
    getProviderState,
    version,
  } = providerHandlers;
  return mergeMiddleware([
    createScaffoldMiddleware({
      version,
      [PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState as JRPCMiddleware<unknown, unknown>,
    }),
    createRequestAccountsMiddleware({ requestAccounts }) as JRPCMiddleware<unknown, unknown>,
    createGetAccountsMiddleware({ getAccounts }) as JRPCMiddleware<unknown, unknown>,
    createProcessTransactionMiddleware({ processTransaction }) as JRPCMiddleware<unknown, unknown>,
    createProcessEthSignMessage({ processEthSignMessage }) as JRPCMiddleware<unknown, unknown>,
    createProcessTypedMessage({ processTypedMessage }) as JRPCMiddleware<unknown, unknown>,
    createProcessTypedMessageV3({ processTypedMessageV3 }) as JRPCMiddleware<unknown, unknown>,
    createProcessTypedMessageV4({ processTypedMessageV4 }) as JRPCMiddleware<unknown, unknown>,
    createProcessPersonalMessage({ processPersonalMessage }) as JRPCMiddleware<unknown, unknown>,
    createPendingNonceMiddleware({ getPendingNonce }) as JRPCMiddleware<unknown, unknown>,
    createPendingTxMiddleware({ getPendingTransactionByHash }) as JRPCMiddleware<unknown, unknown>,
    createProcessEncryptionPublicKeyMiddleware({ processEncryptionPublicKey }) as JRPCMiddleware<unknown, unknown>,
    createProcessDecryptMessageMiddleware({ processDecryptMessage }) as JRPCMiddleware<unknown, unknown>,
    createProcessSwitchEthereumChain({ processSwitchEthereumChain }) as JRPCMiddleware<unknown, unknown>,
    createProcessAddEthereumChain({ processAddEthereumChain }) as JRPCMiddleware<unknown, unknown>,
  ]);
}
