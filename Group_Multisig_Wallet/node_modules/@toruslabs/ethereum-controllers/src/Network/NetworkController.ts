import { BaseController, createEventEmitterProxy, createSwappableProxy, INetworkController } from "@toruslabs/base-controllers";
import { JRPCEngine, JRPCMiddleware, providerFromEngine, SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import { Mutex } from "async-mutex";
import log from "loglevel";

import PollingBlockTracker from "../Block/PollingBlockTracker";
import { SUPPORTED_NETWORKS } from "../utils/constants";
import { EthereumNetworkConfig, EthereumNetworkState, EthereumProviderConfig } from "../utils/interfaces";
import { createEthereumMiddleware, IProviderHandlers } from "./createEthereumMiddleware";
import { createJsonRpcClient } from "./createJsonRpcClient";

export default class NetworkController
  extends BaseController<EthereumNetworkConfig, EthereumNetworkState>
  implements INetworkController<EthereumNetworkConfig, EthereumNetworkState>
{
  name = "NetworkController";

  providerProxy: SafeEventEmitterProvider;

  blockTrackerProxy: PollingBlockTracker;

  private mutex: Mutex = new Mutex();

  private provider?: SafeEventEmitterProvider = null;

  private blockTracker?: PollingBlockTracker = null;

  private baseProviderHandlers: IProviderHandlers;

  constructor({ config, state }: { config?: Partial<EthereumNetworkConfig>; state?: Partial<EthereumNetworkState> }) {
    super({ config, state });

    this.defaultState = {
      chainId: "loading",
      properties: { EIPS_1559: undefined },
      providerConfig: SUPPORTED_NETWORKS.mainnet,
    };

    // when a new network is set,
    // we set to loading first and
    // then when connection succeeds,
    // we update the network
    this.initialize();
  }

  getNetworkIdentifier(): string {
    return this.state.chainId;
  }

  getNetworkRPCUrl(): string {
    return this.state.providerConfig.rpcTarget;
  }

  /**
   * Called by orchestrator once while initializing the class
   * @param providerHandlers - JRPC handlers for provider
   * @returns - provider - Returns the providerProxy
   */
  public initializeProvider(providerHandlers: IProviderHandlers): SafeEventEmitterProvider {
    this.baseProviderHandlers = providerHandlers;
    this.configureProvider();
    this.lookupNetwork(); // Not awaiting this, because we don't want to block the initialization
    return this.providerProxy;
  }

  getProvider(): SafeEventEmitterProvider {
    return this.providerProxy;
  }

  getBlockTracker(): PollingBlockTracker {
    return this.blockTrackerProxy;
  }

  getProviderConfig(): EthereumProviderConfig {
    return this.state.providerConfig;
  }

  setProviderConfig(config: EthereumProviderConfig): void {
    this.update({
      providerConfig: { ...config },
    });
    this.refreshNetwork();
  }

  async getEIP1559Compatibility(): Promise<boolean> {
    const { EIPS_1559 } = this.state.properties;
    // log.info('checking eip 1559 compatibility')
    if (EIPS_1559 !== undefined) {
      return EIPS_1559 as boolean;
    }
    const latestBlock = await this.blockTracker.getLatestBlock();
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
    this.update({ properties: { EIPS_1559: supportsEIP1559 } });
    return supportsEIP1559;
  }

  /**
   * Refreshes the current network code
   */
  async lookupNetwork(): Promise<void> {
    const { chainId, rpcTarget } = this.getProviderConfig();
    if (!chainId || !rpcTarget || !this.provider) {
      this.update({ chainId: "loading", properties: {} });
      return;
    }
    const releaseLock = await this.mutex.acquire();
    try {
      // use eth_chainId
      const [networkChainId] = await Promise.all([this.provider.request<never, string>({ method: "eth_chainId" }), this.getEIP1559Compatibility()]);
      log.info("network fetched chain id", networkChainId);
      // update chain ID
      this.update({
        chainId: networkChainId,
      });
      this.emit("networkDidChange");
    } catch {
      this.update({
        chainId: "loading",
      });
    } finally {
      releaseLock();
    }
  }

  private configureProvider(): void {
    const { chainId, rpcTarget, ...rest } = this.getProviderConfig();
    if (!chainId || !rpcTarget) {
      throw new Error("chainId and rpcTarget must be provider in providerConfig");
    }
    this.configureStandardProvider({ chainId, rpcTarget, ...rest });
  }

  private setNetworkClient({
    networkMiddleware,
    blockTracker,
  }: {
    networkMiddleware: JRPCMiddleware<unknown, unknown>;
    blockTracker: PollingBlockTracker;
  }): void {
    const ethereumMiddleware = createEthereumMiddleware(this.baseProviderHandlers);
    const engine = new JRPCEngine();
    engine.push(ethereumMiddleware);
    engine.push(networkMiddleware);
    const provider = providerFromEngine(engine);
    this.setProvider({ provider, blockTracker });
  }

  private setProvider({ provider, blockTracker }: { provider: SafeEventEmitterProvider; blockTracker: PollingBlockTracker }): void {
    if (this.providerProxy) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      this.providerProxy.setTarget(provider);
    } else {
      this.providerProxy = createSwappableProxy<SafeEventEmitterProvider>(provider);
    }

    if (this.blockTrackerProxy) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      this.blockTrackerProxy.setTarget(blockTracker);
    } else {
      this.blockTrackerProxy = createEventEmitterProxy<PollingBlockTracker>(blockTracker, {
        eventFilter: "skipInternal",
      });
    }

    // set new provider and blockTracker
    this.provider = provider;
    provider.setMaxListeners(10);
    this.blockTracker = blockTracker;
  }

  private configureStandardProvider(providerConfig: EthereumProviderConfig): void {
    const networkClient = createJsonRpcClient(providerConfig, this.config);
    log.info("networkClient", networkClient);
    this.setNetworkClient(networkClient);
  }

  private refreshNetwork() {
    this.update({ chainId: "loading", properties: {} });
    this.configureProvider();
    this.lookupNetwork();
  }
}
