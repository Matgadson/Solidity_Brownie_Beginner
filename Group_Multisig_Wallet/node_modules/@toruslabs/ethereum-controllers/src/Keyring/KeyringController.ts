import { TypedTransaction } from "@ethereumjs/tx";
import { addHexPrefix, bigIntToBytes, ecsign, stripHexPrefix } from "@ethereumjs/util";
import {
  concatSig,
  decrypt,
  EthEncryptedData,
  getEncryptionPublicKey,
  MessageTypes,
  personalSign,
  signTypedData,
  SignTypedDataVersion,
  TypedDataV1,
  TypedMessage,
} from "@metamask/eth-sig-util";
import { BaseConfig, BaseKeyringController, IKeyringController, KeyringControllerState } from "@toruslabs/base-controllers";
import { SigningKey, Wallet } from "ethers";

export default class KeyringController extends BaseKeyringController<Partial<BaseConfig>, KeyringControllerState> implements IKeyringController {
  constructor({ config, state }: { config: Partial<BaseConfig>; state: Partial<KeyringControllerState> }) {
    super({ config, state });
    this.defaultState = { wallets: [] };
    this.initialize();
  }

  async signTransaction<T, U>(tx: T, address: string): Promise<U> {
    const txPayload = tx as unknown as TypedTransaction;
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const signedTx = txPayload.sign(privKey);
    // Newer versions of Ethereumjs-tx are immutable and return a new tx object
    return signedTx === undefined ? (tx as unknown as U) : (signedTx as unknown as U);
  }

  getAccounts(): string[] {
    return this.state.wallets.map((w) => w.publicKey);
  }

  importAccount(accountPrivateKey: string): string {
    const hexPrivateKey = addHexPrefix(accountPrivateKey);
    const signingKey = new SigningKey(hexPrivateKey);
    const wallet = new Wallet(signingKey.privateKey);
    const { address } = wallet;

    const existingWallet = this.state.wallets.find((w) => w.address === address);
    if (existingWallet) return existingWallet.address;

    this.update({
      wallets: [
        ...this.state.wallets,
        {
          publicKey: signingKey.publicKey,
          privateKey: accountPrivateKey,
          address,
        },
      ],
    });
    return address;
  }

  removeAccount(address: string): void {
    const newWallets = [...this.state.wallets];
    const idx = newWallets.findIndex((w) => w.address === address);
    if (idx !== -1) {
      newWallets.splice(idx, 1);
      this.update({ wallets: newWallets });
    }
  }

  getBufferPrivateKey(privateKey: string) {
    const stripped = stripHexPrefix(privateKey);
    return Buffer.from(stripped, "hex");
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(data: string, address: string): Promise<string> {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const messageSig = ecsign(Buffer.from(stripHexPrefix(data), "hex"), privKey);
    const sig = concatSig(Buffer.from(bigIntToBytes(messageSig.v)), Buffer.from(messageSig.r), Buffer.from(messageSig.s));
    return sig;
  }

  // For personal_sign, we need to prefix the message: ensure input is hashed and not buffer of utf-8
  async signPersonalMessage(data: string, address: string) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const sig = personalSign({ privateKey: privKey, data });
    return sig;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData<V extends SignTypedDataVersion, T extends MessageTypes>(
    typedData: V extends "V1" ? TypedDataV1 : TypedMessage<T>,
    address: string,
    version: V
  ) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    return signTypedData({ privateKey: privKey, data: typedData, version });
  }

  signEncryptionPublicKey(address: string) {
    const wallet = this._getWalletForAccount(address);
    return getEncryptionPublicKey(stripHexPrefix(wallet.privateKey));
  }

  decryptMessage(data: EthEncryptedData, address: string) {
    const wallet = this._getWalletForAccount(address);
    return decrypt({ encryptedData: data, privateKey: stripHexPrefix(wallet.privateKey) });
  }

  private _getWalletForAccount(account: string) {
    const address = account.toLowerCase();
    const wallet = this.state.wallets.find((w) => w.address.toLowerCase() === address);
    if (!wallet) throw new Error("Torus Keyring - Unable to find matching address.");
    return wallet;
  }
}
