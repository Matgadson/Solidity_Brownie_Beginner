import { addHexPrefix, isHexString } from "@ethereumjs/util";
import { BaseController } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import { cloneDeep } from "lodash";
import log from "loglevel";

import NetworkController from "../Network/NetworkController";
import { GAS_ESTIMATE_TYPES } from "../utils/constants";
import { idleTimeTracker } from "../utils/helpers";
import { EthereumNetworkState } from "../utils/interfaces";
import {
  calculateTimeEstimate,
  fetchEthGasPriceEstimate as defaultFetchEthGasPriceEstimate,
  fetchGasEstimates as defaultFetchGasEstimates,
  fetchGasEstimatesViaEthFeeHistory as defaultFetchGasEstimatesViaEthFeeHistory,
  fetchLegacyGasPriceEstimates as defaultFetchLegacyGasPriceEstimates,
} from "./gasUtil";
import { EthereumGasConfig, EthereumGasFeeEstimates, EthereumGasState, EthereumLegacyGasFeeEstimates, GasFeeTimeBounds } from "./IGasFeeController";
const GAS_FEE_API = "https://mock-gas-server.herokuapp.com/";
const LEGACY_GAS_PRICES_API_URL = "https://api.metaswap.codefi.network/gasPrices";

interface IGasFeeControllerOptions {
  config?: Partial<EthereumGasConfig>;
  state?: Partial<EthereumGasState>;
  getNetworkIdentifier: NetworkController["getNetworkIdentifier"];
  getProvider: NetworkController["getProvider"];
  getCurrentNetworkEIP1559Compatibility: NetworkController["getEIP1559Compatibility"];
  getCurrentAccountEIP1559Compatibility: (address: string) => boolean;
  getCurrentNetworkLegacyGasAPICompatibility: () => boolean;
  fetchGasEstimates?: (url: string) => Promise<EthereumGasFeeEstimates>;
  fetchEthGasPriceEstimate?: (provider: SafeEventEmitterProvider) => Promise<{ gasPrice: string }>;
  fetchLegacyGasPriceEstimates?: (url: string) => Promise<EthereumLegacyGasFeeEstimates>;
  fetchGasEstimatesViaEthFeeHistory?: (provider: SafeEventEmitterProvider) => Promise<EthereumGasFeeEstimates>;
  onNetworkStateChange: (listener: (networkState: EthereumNetworkState) => void) => void;
}

/**
 * Returns gas prices in dec gwei
 */
export default class GasFeeController extends BaseController<EthereumGasConfig, EthereumGasState> {
  name = "GasFeeController";

  // https://0x.org/docs/introduction/0x-cheat-sheet#swap-api-endpoints
  readonly API_SUPPORTED_CHAINIDS = new Set(["0x1", "0x5", "0x13881", "0xa4b1", "0xa86a", "0x2105", "0x38", "0xfa", "0xa", "0x89"]);

  private intervalId: number;

  private provider: SafeEventEmitterProvider;

  private currentChainId: string;

  private getNetworkIdentifier: NetworkController["getNetworkIdentifier"];

  private getProvider: NetworkController["getProvider"];

  private fetchGasEstimates: (url: string) => Promise<EthereumGasFeeEstimates>;

  private fetchGasEstimatesViaEthFeeHistory: (provider: SafeEventEmitterProvider) => Promise<EthereumGasFeeEstimates>;

  private fetchEthGasPriceEstimate: (provider: SafeEventEmitterProvider) => Promise<{ gasPrice: string }>;

  private fetchLegacyGasPriceEstimates: (url: string) => Promise<EthereumLegacyGasFeeEstimates>;

  private getCurrentNetworkEIP1559Compatibility: NetworkController["getEIP1559Compatibility"];

  private getCurrentAccountEIP1559Compatibility: (address?: string) => boolean;

  private getCurrentNetworkLegacyGasAPICompatibility: () => boolean;

  constructor({
    config,
    state,
    getNetworkIdentifier,
    getProvider,
    fetchGasEstimates = defaultFetchGasEstimates,
    fetchEthGasPriceEstimate = defaultFetchEthGasPriceEstimate,
    fetchLegacyGasPriceEstimates = defaultFetchLegacyGasPriceEstimates,
    fetchGasEstimatesViaEthFeeHistory = defaultFetchGasEstimatesViaEthFeeHistory,
    getCurrentNetworkLegacyGasAPICompatibility,
    getCurrentNetworkEIP1559Compatibility,
    getCurrentAccountEIP1559Compatibility,
    onNetworkStateChange,
  }: IGasFeeControllerOptions) {
    super({ config, state });
    this.getNetworkIdentifier = getNetworkIdentifier;
    this.getProvider = getProvider;
    this.fetchGasEstimates = fetchGasEstimates;
    this.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate;
    this.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates;
    this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
    this.getCurrentNetworkLegacyGasAPICompatibility = getCurrentNetworkLegacyGasAPICompatibility;
    this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
    this.fetchGasEstimatesViaEthFeeHistory = fetchGasEstimatesViaEthFeeHistory;

    this.defaultConfig = {
      interval: 30_000,
      legacyAPIEndpoint: LEGACY_GAS_PRICES_API_URL,
      EIP1559APIEndpoint: GAS_FEE_API,
    };

    this.defaultState = {
      gasFeeEstimates: {} as EthereumGasFeeEstimates,
      estimatedGasFeeTimeBounds: {},
      gasEstimateType: GAS_ESTIMATE_TYPES.NONE,
    };
    // Initialize.
    this.currentChainId = this.getNetworkIdentifier();
    this.provider = this.getProvider();
    this.initialize();
    onNetworkStateChange(() => {
      this.onNetworkStateChange();
    });
  }

  async onNetworkStateChange() {
    this.provider = this.getProvider();
    const newChainId = this.getNetworkIdentifier();
    if (this.currentChainId !== newChainId) {
      this.currentChainId = newChainId;
      await this.resetPolling();
    }
  }

  async resetPolling() {
    this.stopPolling();
    await this.getGasFeeEstimatesAndStartPolling();
  }

  async fetchGasFeeEstimates() {
    return this._fetchGasFeeEstimateData();
  }

  async getGasFeeEstimatesAndStartPolling() {
    await this._fetchGasFeeEstimateData();
    this._startPolling();
  }

  disconnectPoller() {
    this.stopPolling();
  }

  /**
   * Prepare to discard this controller.
   *
   * This stops any active polling.
   */
  destroy() {
    this.stopPolling();
  }

  stopPolling() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
    this.resetState();
  }

  /**
   * Gets and sets gasFeeEstimates in state
   *
   * @returns GasFeeEstimates
   */
  private async _fetchGasFeeEstimateData(): Promise<EthereumGasState> {
    let isEIP1559Compatible: boolean;
    const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();

    const chainId = this.getNetworkIdentifier();
    if (chainId === "loading") return;
    let chainIdInt: number;
    if (typeof chainId === "string" && isHexString(addHexPrefix(chainId))) {
      chainIdInt = Number.parseInt(chainId, 16);
    }
    try {
      isEIP1559Compatible = await this.getEIP1559Compatibility();
      log.info("eip1559 compatible", isEIP1559Compatible);
    } catch (error) {
      log.warn(error);
      isEIP1559Compatible = false;
    }

    let newState = cloneDeep(this.defaultState);

    try {
      if (isEIP1559Compatible) {
        let estimates: EthereumGasFeeEstimates;
        try {
          if (this.API_SUPPORTED_CHAINIDS.has(chainId)) {
            estimates = await this.fetchGasEstimates(this.config.EIP1559APIEndpoint.replace("<chain_id>", `${chainIdInt}`));
          } else {
            throw new Error("ChainId not supported by api");
          }
        } catch (error) {
          estimates = await this.fetchGasEstimatesViaEthFeeHistory(this.provider);
        }
        const { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = estimates.medium;
        const estimatedGasFeeTimeBounds = this.getTimeEstimate(suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas);
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds,
          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET,
        };
      } else if (isLegacyGasAPICompatible) {
        const estimates = await this.fetchLegacyGasPriceEstimates(this.config.legacyAPIEndpoint.replace("<chain_id>", `${chainIdInt}`));
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds: {},
          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY,
        };
      } else {
        throw new Error("Main gas fee/price estimation failed. Use fallback");
      }
    } catch {
      try {
        const estimates = await this.fetchEthGasPriceEstimate(this.provider);
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds: {},
          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE,
        };
      } catch (error) {
        throw new Error(`Gas fee/price estimation failed. Message: ${(error as Error).message}`);
      }
    }
    this.update(newState);

    return newState;
  }

  private async _startPolling() {
    this._poll();
  }

  private async _poll() {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
    }
    this.intervalId = window.setInterval(async () => {
      if (!idleTimeTracker.checkIfIdle()) {
        await this._fetchGasFeeEstimateData();
      }
    }, this.config.interval);
  }

  private resetState() {
    this.update(cloneDeep(this.defaultState));
  }

  private async getEIP1559Compatibility(): Promise<boolean> {
    const currentNetworkIsEIP1559Compatible = await this.getCurrentNetworkEIP1559Compatibility();
    const currentAccountIsEIP1559Compatible = this.getCurrentAccountEIP1559Compatibility?.() ?? true;

    return currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible;
  }

  private getTimeEstimate(maxPriorityFeePerGas: string, maxFeePerGas: string): GasFeeTimeBounds {
    if (!this.state.gasFeeEstimates || this.state.gasEstimateType !== GAS_ESTIMATE_TYPES.FEE_MARKET) {
      return {};
    }
    return calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates as EthereumGasFeeEstimates);
  }
}
