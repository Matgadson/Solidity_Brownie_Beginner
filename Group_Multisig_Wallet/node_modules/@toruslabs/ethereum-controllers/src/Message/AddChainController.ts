import { BaseConfig, randomId } from "@toruslabs/base-controllers";
import { JRPCRequest } from "@toruslabs/openlogin-jrpc";
import log from "loglevel";

import NetworkController from "../Network/NetworkController";
import PreferencesController from "../Preferences/PreferencesController";
import { MESSAGE_EVENTS, MessageStatus, METHOD_TYPES } from "../utils/constants";
import { AddChainMessage, AddChainMessageParams, UserRequestApprovalParams } from "../utils/interfaces";
import AbstractMessageController, { MessageControllerState } from "./AbstractMessageController";
import { validateAddChainData } from "./utils";

export class AddChainController extends AbstractMessageController<AddChainMessage, AddChainMessageParams> {
  override name = "AddChainController";

  protected addChain: PreferencesController["addChain"];

  constructor({
    config,
    state,
    getNetworkIdentifier,
    addChain,
  }: {
    config: Partial<BaseConfig>;
    state: Partial<MessageControllerState<AddChainMessage>>;
    getNetworkIdentifier: NetworkController["getNetworkIdentifier"];
    addChain: PreferencesController["addChain"];
  }) {
    super({ config, state, getNetworkIdentifier });
    this.addChain = addChain;
    this.initialize();
  }

  async processAddChain(messageId: string): Promise<string> {
    try {
      const msgObject = this.getMessage(messageId);
      await this.approveMessage(messageId, msgObject.messageParams);
      this.addChain(msgObject.messageParams);
      this.updateMessage({ ...msgObject, rawSig: JSON.stringify(msgObject.messageParams) });
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return null;
    } catch (error) {
      log.error(error);
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }

  async addNewUnapprovedMessage(messageParams: AddChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }

  async addUnapprovedMessage(messageParams: AddChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    validateAddChainData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    const messageId = messageParams.id || randomId();
    const messageData: AddChainMessage = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ADD_CHAIN,
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, { messageData, req });
    return messageId;
  }

  prepMessageForSigning(messageParams: AddChainMessageParams): Promise<AddChainMessageParams> {
    return Promise.resolve(messageParams);
  }
}
