// import { isValidAddress } from "@ethereumjs/util";
import { BaseConfig, randomId } from "@toruslabs/base-controllers";
import { JRPCRequest } from "@toruslabs/openlogin-jrpc";
import log from "loglevel";

import KeyringController from "../Keyring/KeyringController";
import NetworkController from "../Network/NetworkController";
import { MESSAGE_EVENTS, MessageStatus, METHOD_TYPES } from "../utils/constants";
import { DecryptMessage, DecryptMessageParams, Message, UserRequestApprovalParams } from "../utils/interfaces";
import AbstractMessageController, { MessageControllerState } from "./AbstractMessageController";
import { normalizeMessageData, parseDecryptMessageData, validateDecryptedMessageData } from "./utils";

export class DecryptMessageController extends AbstractMessageController<DecryptMessage, DecryptMessageParams> {
  override name = "DecryptMessageController";

  protected decryptMessage: KeyringController["decryptMessage"];

  constructor({
    config,
    state,
    decryptMessage,
    getNetworkIdentifier,
  }: {
    config: Partial<BaseConfig>;
    state: Partial<MessageControllerState<Message>>;
    decryptMessage: KeyringController["decryptMessage"];
    getNetworkIdentifier: NetworkController["getNetworkIdentifier"];
  }) {
    super({ config, state, getNetworkIdentifier });
    this.decryptMessage = decryptMessage;
    this.initialize();
  }

  async processDecryptMessage(messageId: string): Promise<string> {
    try {
      const msgObject = this.getMessage(messageId);
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const parsedData = parseDecryptMessageData(cleanMsgParams.data);
      const rawSig = this.decryptMessage(parsedData, cleanMsgParams.from);
      this.updateMessage({ ...msgObject, rawSig });
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      log.error(error);
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }

  async addNewUnapprovedMessage(messageParams: DecryptMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }

  async addUnapprovedMessage(messageParams: DecryptMessageParams, req?: JRPCRequest<unknown> & UserRequestApprovalParams) {
    validateDecryptedMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.data = normalizeMessageData(messageParams.data);
    const messageId = messageParams.id || randomId();
    const messageData: DecryptMessage = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_DECRYPT,
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, { messageData, req });
    return messageId;
  }

  prepMessageForSigning(messageParams: DecryptMessageParams): Promise<DecryptMessageParams> {
    return Promise.resolve({ ...messageParams });
  }
}
