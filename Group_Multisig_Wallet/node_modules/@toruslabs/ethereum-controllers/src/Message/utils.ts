import { addHexPrefix, bytesToHex, isValidAddress, stripHexPrefix } from "@ethereumjs/util";
import { EthEncryptedData, TYPED_MESSAGE_SCHEMA, TypedDataV1Field, typedSignatureHash } from "@metamask/eth-sig-util";
import { isHexString, JsonRpcProvider, toQuantity } from "ethers";
import { validate } from "jsonschema";

import {
  AddChainMessageParams,
  DecryptMessageParams,
  EncryptionPublicKeyParams,
  MessageParams,
  SwitchChainMessageParams,
  TypedMessageParams,
} from "../utils/interfaces";

const hexRe = /^[0-9A-Fa-f]+$/gu;

export function validateAddress(address: string, propertyName: string) {
  if (!address || typeof address !== "string" || !isValidAddress(address)) {
    throw new Error(`Invalid "${propertyName}" address: ${address} must be a valid string.`);
  }
}

export function validateSignMessageData(messageData: MessageParams) {
  const { from, data } = messageData;
  validateAddress(from, "from");

  if (!data || typeof data !== "string") {
    throw new Error(`Invalid message "data": ${data} must be a valid string.`);
  }
}

export function normalizeMessageData(data: string): string {
  try {
    const stripped = stripHexPrefix(data);
    if (stripped.match(hexRe)) {
      return addHexPrefix(stripped);
    }
  } catch (e) {}
  return bytesToHex(Buffer.from(data, "utf8"));
}

export function validateTypedSignMessageDataV1(messageData: TypedMessageParams) {
  validateAddress(messageData.from, "from");

  if (!messageData.data || !Array.isArray(messageData.data)) {
    throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
  }

  try {
    // typedSignatureHash will throw if the data is invalid.
    typedSignatureHash(messageData.data as TypedDataV1Field[]);
  } catch (e) {
    throw new Error(`Expected EIP712 typed data.`);
  }
}

export function validateTypedSignMessageDataV3V4(messageData: TypedMessageParams, currentChainId: string) {
  validateAddress(messageData.from, "from");

  if (!messageData.data || Array.isArray(messageData.data) || (typeof messageData.data !== "object" && typeof messageData.data !== "string")) {
    throw new Error(`Invalid message "data": Must be a valid string or object.`);
  }

  let data;
  if (typeof messageData.data === "object") {
    data = messageData.data;
  } else {
    try {
      data = JSON.parse(messageData.data);
    } catch (e) {
      throw new Error("Data must be passed as a valid JSON string.");
    }
  }

  const validation = validate(data, TYPED_MESSAGE_SCHEMA);
  if (validation.errors.length > 0) {
    throw new Error("Data must conform to EIP-712 schema. See https://git.io/fNtcx.");
  }

  if (!currentChainId) {
    throw new Error("Current chainId cannot be null or undefined.");
  }

  let { chainId } = data.domain;
  if (chainId) {
    if (typeof chainId === "string") {
      chainId = parseInt(chainId, chainId.startsWith("0x") ? 16 : 10);
    }

    const activeChainId = parseInt(currentChainId, 16);
    if (Number.isNaN(activeChainId)) {
      throw new Error(`Cannot sign messages for chainId "${chainId}", because MetaMask is switching networks.`);
    }

    if (chainId !== activeChainId) {
      throw new Error(`Provided chainId "${chainId}" must match the active chainId "${activeChainId}"`);
    }
  }
}

export function validateEncryptionPublicKeyMessageData(messageData: EncryptionPublicKeyParams) {
  const { from } = messageData;
  validateAddress(from, "from");
}

export function validateDecryptedMessageData(messageData: DecryptMessageParams) {
  const { from } = messageData;
  validateAddress(from, "from");
}

export function parseDecryptMessageData(data: string): EthEncryptedData {
  const stripped = stripHexPrefix(data);
  const buffer = Buffer.from(stripped, "hex");
  return JSON.parse(buffer.toString("utf8")) as EthEncryptedData;
}

export async function validateAddChainData(data: AddChainMessageParams) {
  const { chainId, rpcUrls, nativeCurrency } = data || {};

  if (!chainId) {
    throw new Error("Invalid add chain params: please pass chainId in params");
  }

  if (!isHexString(chainId)) {
    throw new Error("Invalid add chain params: please pass a valid hex chainId in params, for: ex: 0x1");
  }

  if (!rpcUrls || rpcUrls.length === 0) throw new Error("params.rpcUrls not provided");
  if (!nativeCurrency) throw new Error("params.nativeCurrency not provided");
  const { name, symbol, decimals } = nativeCurrency;

  if (!name) throw new Error("params.nativeCurrency.name not provided");
  if (!symbol) throw new Error("params.nativeCurrency.symbol not provided");
  if (decimals === undefined) throw new Error("params.nativeCurrency.decimals not provided");

  const _web3 = new JsonRpcProvider(rpcUrls[0], "any");
  const { chainId: networkChainID } = await _web3.getNetwork();
  if (Number.parseInt(networkChainID.toString()) !== Number.parseInt(chainId, 16)) {
    throw new Error(
      `Provided rpc url's chainId version is not matching with provided chainId, expected: ${toQuantity(networkChainID)}, received: ${chainId}`
    );
  }
}

export function validateSwitchChainData(data: SwitchChainMessageParams) {
  const { chainId } = data || {};

  if (!chainId) {
    throw new Error("Invalid switch chain params: please pass chainId in params");
  }

  if (!isHexString(chainId)) {
    throw new Error("Invalid switch chain params: please pass a valid hex chainId in params, for: ex: 0x1");
  }
}
