import { BaseConfig, randomId } from "@toruslabs/base-controllers";
import { JRPCRequest } from "@toruslabs/openlogin-jrpc";
import log from "loglevel";

import NetworkController from "../Network/NetworkController";
import PreferencesController from "../Preferences/PreferencesController";
import { MESSAGE_EVENTS, MessageStatus, METHOD_TYPES } from "../utils/constants";
import { SwitchChainMessage, SwitchChainMessageParams, UserRequestApprovalParams } from "../utils/interfaces";
import AbstractMessageController, { MessageControllerState } from "./AbstractMessageController";
import { validateSwitchChainData } from "./utils";

export class SwitchChainController extends AbstractMessageController<SwitchChainMessage, SwitchChainMessageParams> {
  override name = "SwitchChainController";

  protected switchChain: PreferencesController["switchChain"];

  constructor({
    config,
    state,
    getNetworkIdentifier,
    switchChain,
  }: {
    config: Partial<BaseConfig>;
    state: Partial<MessageControllerState<SwitchChainMessage>>;
    getNetworkIdentifier: NetworkController["getNetworkIdentifier"];
    switchChain: PreferencesController["switchChain"];
  }) {
    super({ config, state, getNetworkIdentifier });

    this.switchChain = switchChain;
    this.initialize();
  }

  async processSwitchChain(messageId: string): Promise<string> {
    try {
      const msgObject = this.getMessage(messageId);
      await this.approveMessage(messageId, msgObject.messageParams);
      this.switchChain({ chainId: msgObject.messageParams.chainId });
      this.updateMessage({ ...msgObject, rawSig: JSON.stringify(msgObject.messageParams) });
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return null;
    } catch (error) {
      log.error(error);
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }

  async addNewUnapprovedMessage(messageParams: SwitchChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }

  async addUnapprovedMessage(messageParams: SwitchChainMessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    validateSwitchChainData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    const messageId = messageParams.id || randomId();
    const messageData: SwitchChainMessage = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.SWITCH_CHAIN,
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, { messageData, req });
    return messageId;
  }

  prepMessageForSigning(messageParams: SwitchChainMessageParams): Promise<SwitchChainMessageParams> {
    return Promise.resolve(messageParams);
  }
}
