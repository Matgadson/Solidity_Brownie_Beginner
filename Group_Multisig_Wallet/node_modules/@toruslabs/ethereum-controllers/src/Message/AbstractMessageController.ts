import { SignTypedDataVersion } from "@metamask/eth-sig-util";
import { providerErrors, rpcErrors } from "@metamask/rpc-errors";
import { BaseConfig, BaseController, BaseState } from "@toruslabs/base-controllers";
import { JRPCRequest, Json } from "@toruslabs/openlogin-jrpc";

import NetworkController from "../Network/NetworkController";
import { MessageStatus } from "../utils/constants";
import { AbstractMessage, BaseRequestParams, MessageStatusType, UserRequestApprovalParams } from "../utils/interfaces";

export interface MessageControllerState<M extends AbstractMessage> extends BaseState {
  unapprovedMessages: Record<string, M>;
  unapprovedMessagesCount: number;
}

export default abstract class AbstractMessageController<M extends AbstractMessage, P extends BaseRequestParams> extends BaseController<
  BaseConfig,
  MessageControllerState<M>
> {
  protected messages: M[];

  protected getNetworkIdentifier: NetworkController["getNetworkIdentifier"];

  /**
   * Controller in charge of managing - storing, adding, removing, updating - Messages.
   *
   */
  constructor({
    config,
    state,
    getNetworkIdentifier,
  }: {
    config?: Partial<BaseConfig>;
    state?: Partial<MessageControllerState<M>>;
    getNetworkIdentifier: NetworkController["getNetworkIdentifier"];
  }) {
    super({ config, state });
    this.defaultState = {
      unapprovedMessages: {},
      unapprovedMessagesCount: 0,
    };
    this.messages = [];
    this.defaultConfig = {};
    this.getNetworkIdentifier = getNetworkIdentifier;
    super.initialize();
  }

  getMessage(messageId: string) {
    return this.messages.find((message) => message.id === messageId);
  }

  getAllMessages() {
    return this.messages;
  }

  setMetadata(messageId: string, metadata: Json) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.metadata = metadata;
    this.updateMessage(message);
  }

  getUnapprovedMessages() {
    return this.messages
      .filter((message) => message.status === MessageStatus.UNAPPROVED)
      .reduce((result: { [key: string]: M }, message: M) => {
        result[message.id] = message;
        return result;
      }, {}) as { [key: string]: M };
  }

  async addMessage(message: M) {
    this.messages.push(message);
    this.saveMessageList();
  }

  approveMessage(messageId: string, messageParams: P): Promise<P> {
    this.setMessageStatus(messageId, MessageStatus.APPROVED);
    return this.prepMessageForSigning(messageParams);
  }

  setMessageStatus(messageId: string, status: MessageStatusType) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.status = status;
    this.updateMessage(message);
    this.emit(`${messageId}:${status}`, message);
    if (status === MessageStatus.REJECTED || status === MessageStatus.SIGNED || status === MessageStatus.FAILED) {
      this.emit(`${messageId}:finished`, message);
    }
  }

  async waitForFinishStatus(msgParams: P, messageName: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const handleFinished = (msg: M) => {
        if (msg.status === MessageStatus.REJECTED) {
          return reject(providerErrors.userRejectedRequest(`${messageName} Signature: User denied message signature`));
        }
        if (msg.status === MessageStatus.FAILED) {
          return reject(rpcErrors.internal(`${messageName} Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === MessageStatus.SIGNED) {
          return resolve(msg.rawSig as string);
        }

        return reject(rpcErrors.internal(`${messageName} Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
      };
      this.once(`${msgParams.id}:finished`, handleFinished);
    });
  }

  protected updateMessage(message: M) {
    const index = this.messages.findIndex((msg) => message.id === msg.id);
    if (index !== -1) {
      this.messages[index] = message;
    }
    this.saveMessageList();
  }

  protected saveMessageList() {
    const unapprovedMessages = this.getUnapprovedMessages();
    const unapprovedMessagesCount = Object.keys(unapprovedMessages).length;
    this.update({ unapprovedMessages, unapprovedMessagesCount });
  }

  abstract prepMessageForSigning(messageParams: P): Promise<P>;

  abstract addUnapprovedMessage(
    messageParams: P,
    request: JRPCRequest<P> & UserRequestApprovalParams,
    version?: SignTypedDataVersion
  ): Promise<string>;
}
