import { MessageTypes, SignTypedDataVersion, TypedDataV1, TypedMessage as EthSigTypedMessage } from "@metamask/eth-sig-util";
import { BaseConfig, randomId } from "@toruslabs/base-controllers";
import { JRPCRequest } from "@toruslabs/openlogin-jrpc";
import log from "loglevel";

import KeyringController from "../Keyring/KeyringController";
import NetworkController from "../Network/NetworkController";
import { MESSAGE_EVENTS, MessageStatus, METHOD_TYPES } from "../utils/constants";
import { METHOD_TYPES_TYPE, TypedMessage, TypedMessageParams, UserRequestApprovalParams } from "../utils/interfaces";
import AbstractMessageController, { MessageControllerState } from "./AbstractMessageController";
import { validateTypedSignMessageDataV1, validateTypedSignMessageDataV3V4 } from "./utils";

function getMessageType(version: SignTypedDataVersion): METHOD_TYPES_TYPE {
  switch (version) {
    case SignTypedDataVersion.V1:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA;
    case SignTypedDataVersion.V3:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3;
    case SignTypedDataVersion.V4:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4;
    default:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA;
  }
}

export class TypedMessageController extends AbstractMessageController<TypedMessage, TypedMessageParams> {
  override name = "TypedMessageController";

  protected signTypedData: KeyringController["signTypedData"];

  constructor({
    config,
    state,
    signTypedData,
    getNetworkIdentifier,
  }: {
    config: Partial<BaseConfig>;
    state: Partial<MessageControllerState<TypedMessage>>;
    signTypedData: KeyringController["signTypedData"];
    getNetworkIdentifier: NetworkController["getNetworkIdentifier"];
  }) {
    super({ config, state, getNetworkIdentifier });
    this.signTypedData = signTypedData;
    this.initialize();
  }

  async processPersonalSignMessage(messageId: string): Promise<string> {
    try {
      const msgObject = this.getMessage(messageId);
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const msgData = cleanMsgParams.version === SignTypedDataVersion.V1 ? cleanMsgParams.data : JSON.parse(cleanMsgParams.data as string);
      const rawSig = await this.signTypedData(msgData as TypedDataV1 | EthSigTypedMessage<MessageTypes>, cleanMsgParams.from, cleanMsgParams.version);
      this.updateMessage({ ...msgObject, rawSig });
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      log.error(error);
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }

  async addNewUnapprovedMessage(
    messageParams: TypedMessageParams,
    req: JRPCRequest<unknown> & UserRequestApprovalParams,
    version: SignTypedDataVersion
  ): Promise<string> {
    await this.addUnapprovedMessage(messageParams, req, version);
    return this.waitForFinishStatus(messageParams, this.name);
  }

  async addUnapprovedMessage(
    messageParams: TypedMessageParams,
    req: JRPCRequest<unknown> & UserRequestApprovalParams,
    version: SignTypedDataVersion
  ): Promise<string> {
    if (version === SignTypedDataVersion.V1) {
      validateTypedSignMessageDataV1(messageParams);
    }

    if (version === SignTypedDataVersion.V3 || version === SignTypedDataVersion.V4) {
      const currentChainId = this.getNetworkIdentifier();
      validateTypedSignMessageDataV3V4(messageParams, currentChainId);
    }

    if (typeof messageParams.data !== "string" && (version === SignTypedDataVersion.V3 || version === SignTypedDataVersion.V4)) {
      messageParams.data = JSON.stringify(messageParams.data);
    }

    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.version = version;
    const messageId = messageParams.id || randomId();
    const messageData: TypedMessage = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: getMessageType(version),
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, { messageData, req });
    return messageId;
  }

  prepMessageForSigning(messageParams: TypedMessageParams): Promise<TypedMessageParams> {
    return Promise.resolve(messageParams);
  }
}
