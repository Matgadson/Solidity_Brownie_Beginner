import { BaseConfig, randomId } from "@toruslabs/base-controllers";
import { JRPCRequest } from "@toruslabs/openlogin-jrpc";
import log from "loglevel";

import KeyringController from "../Keyring/KeyringController";
import NetworkController from "../Network/NetworkController";
import { MESSAGE_EVENTS, MessageStatus, METHOD_TYPES } from "../utils/constants";
import { Message, MessageParams, UserRequestApprovalParams } from "../utils/interfaces";
import AbstractMessageController, { MessageControllerState } from "./AbstractMessageController";
import { normalizeMessageData, validateSignMessageData } from "./utils";

export class MessageController extends AbstractMessageController<Message, MessageParams> {
  override name = "MessageController";

  protected signMessage: KeyringController["signMessage"];

  constructor({
    config,
    state,
    signMessage,
    getNetworkIdentifier,
  }: {
    config: Partial<BaseConfig>;
    state: Partial<MessageControllerState<Message>>;
    signMessage: KeyringController["signMessage"];
    getNetworkIdentifier: NetworkController["getNetworkIdentifier"];
  }) {
    super({ config, state, getNetworkIdentifier });
    this.signMessage = signMessage;
    this.initialize();
  }

  async processSignMessage(messageId: string): Promise<string> {
    try {
      const msgObject = this.getMessage(messageId);
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const rawSig = await this.signMessage(cleanMsgParams.data, cleanMsgParams.from);
      this.updateMessage({ ...msgObject, rawSig });
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      log.error(error);
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }

  async addNewUnapprovedMessage(messageParams: MessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }

  async addUnapprovedMessage(messageParams: MessageParams, req: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    validateSignMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.data = normalizeMessageData(messageParams.data);
    const messageId = messageParams.id || randomId();
    const messageData: Message = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_SIGN,
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, { messageData, req });
    return messageId;
  }

  prepMessageForSigning(messageParams: MessageParams): Promise<MessageParams> {
    return Promise.resolve(messageParams);
  }
}
