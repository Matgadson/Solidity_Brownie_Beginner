// import { isValidAddress } from "@ethereumjs/util";
import { BaseConfig, randomId } from "@toruslabs/base-controllers";
import { JRPCRequest } from "@toruslabs/openlogin-jrpc";
import log from "loglevel";

import KeyringController from "../Keyring/KeyringController";
import NetworkController from "../Network/NetworkController";
import { MESSAGE_EVENTS, MessageStatus, METHOD_TYPES } from "../utils/constants";
import { EncryptionPublicKey, EncryptionPublicKeyParams, UserRequestApprovalParams } from "../utils/interfaces";
import AbstractMessageController, { MessageControllerState } from "./AbstractMessageController";
import { validateEncryptionPublicKeyMessageData } from "./utils";

export class EncryptionPublicKeyController extends AbstractMessageController<EncryptionPublicKey, EncryptionPublicKeyParams> {
  override name = "EncryptionPublicKeyController";

  protected signEncryptionPublicKey: KeyringController["signEncryptionPublicKey"];

  constructor({
    config,
    state,
    signEncryptionPublicKey,
    getNetworkIdentifier,
  }: {
    config: Partial<BaseConfig>;
    state: Partial<MessageControllerState<EncryptionPublicKey>>;
    signEncryptionPublicKey: KeyringController["signEncryptionPublicKey"];
    getNetworkIdentifier: NetworkController["getNetworkIdentifier"];
  }) {
    super({ config, state, getNetworkIdentifier });
    this.signEncryptionPublicKey = signEncryptionPublicKey;
    this.initialize();
  }

  async processGetEncryptionPublicKey(messageId: string): Promise<string> {
    try {
      const msgObject = this.getMessage(messageId);
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const publicKey = this.signEncryptionPublicKey(cleanMsgParams.from);
      this.updateMessage({ ...msgObject, rawSig: publicKey });
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return publicKey;
    } catch (error) {
      log.error(error);
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }

  async addNewUnapprovedMessage(messageParams: EncryptionPublicKeyParams, req: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }

  async addUnapprovedMessage(messageParams: EncryptionPublicKeyParams, req?: JRPCRequest<unknown> & UserRequestApprovalParams): Promise<string> {
    validateEncryptionPublicKeyMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    const messageId = messageParams.id || randomId();
    const messageData: EncryptionPublicKey = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY,
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, { messageData, req });
    return messageId;
  }

  prepMessageForSigning(messageParams: EncryptionPublicKeyParams): Promise<EncryptionPublicKeyParams> {
    // From should be the public key for the encryption
    return Promise.resolve({ ...messageParams, from: messageParams.data });
  }
}
