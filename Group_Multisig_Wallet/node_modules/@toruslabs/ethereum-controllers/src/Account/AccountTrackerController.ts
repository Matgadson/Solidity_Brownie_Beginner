import { AccountTrackerConfig, AccountTrackerState, BaseController, IAccountTrackerController, PreferencesState } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import { Mutex } from "async-mutex";
import { BrowserProvider, Contract, toQuantity } from "ethers";
import log from "loglevel";

import PollingBlockTracker from "../Block/PollingBlockTracker";
import NetworkController from "../Network/NetworkController";
import { singleBalanceCheckerAbi } from "../utils/abis";
import { SINGLE_CALL_BALANCES_ADDRESSES } from "../utils/contractAddresses";
import { EthereumBlock, ExtendedAddressPreferences } from "../utils/interfaces";

interface AccountTrackerControllerOptions {
  config: AccountTrackerConfig<EthereumBlock>;
  state: Partial<AccountTrackerState>;
  provider: SafeEventEmitterProvider;
  blockTracker?: PollingBlockTracker;
  getIdentities: () => PreferencesState<ExtendedAddressPreferences>["identities"];
  onPreferencesStateChange: (listener: (preferencesState: PreferencesState<ExtendedAddressPreferences>) => void) => void;
  getCurrentChainId: NetworkController["getNetworkIdentifier"];
}

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

/**
 * Tracks accounts based on blocks.
 * If block tracker provides latest block, we query accounts from it.
 * Preferences state changes also retrigger accounts update.
 * Network state changes also retrigger accounts update.
 */
class AccountTrackerController
  extends BaseController<AccountTrackerConfig<EthereumBlock>, AccountTrackerState>
  implements IAccountTrackerController<AccountTrackerConfig<EthereumBlock>, AccountTrackerState>
{
  private provider!: SafeEventEmitterProvider;

  private blockTracker!: PollingBlockTracker;

  private mutex = new Mutex();

  private ethersProvider!: BrowserProvider;

  private getIdentities!: AccountTrackerControllerOptions["getIdentities"];

  private getCurrentChainId: NetworkController["getNetworkIdentifier"];

  constructor({
    config,
    state,
    provider,
    blockTracker,
    getIdentities,
    onPreferencesStateChange,
    getCurrentChainId,
  }: AccountTrackerControllerOptions) {
    super({ config, state });
    this.defaultState = {
      accounts: {},
    };
    this.defaultConfig = {
      _currentBlock: null,
    };
    this.initialize();
    this.provider = provider;
    this.blockTracker = blockTracker;
    this.ethersProvider = new BrowserProvider(this.provider, "any");

    // Initiate block tracker internal tracking.
    this.blockTracker.on("latest", (block: EthereumBlock) => {
      this.configure({ _currentBlock: block });
      this.refresh();
    });

    this.getIdentities = getIdentities;
    this.getCurrentChainId = getCurrentChainId;

    onPreferencesStateChange(() => {
      log.info("onPreferencesStateChange called");
      const refreshNeeded = this.syncAccounts();
      if (refreshNeeded) this.refresh();
    });
  }

  syncAccounts(): boolean {
    const { accounts } = this.state;
    const addresses = Object.keys(this.getIdentities());
    const existing = Object.keys(accounts);
    const newAddresses = addresses.filter((address) => existing.indexOf(address) === -1);
    const oldAddresses = existing.filter((address) => addresses.indexOf(address) === -1);
    let isUpdated = false;
    newAddresses.forEach((address) => {
      isUpdated = true;
      accounts[address] = { balance: "0x0" };
    });
    oldAddresses.forEach((address) => {
      isUpdated = true;
      delete accounts[address];
    });
    this.update({ accounts: { ...accounts } });
    return isUpdated;
  }

  async refresh(): Promise<void> {
    const releaseLock = await this.mutex.acquire();
    try {
      const currentBlock = this.config._currentBlock;
      if (!currentBlock) return;
      this._updateAccounts();
    } catch (error) {
    } finally {
      releaseLock();
    }
  }

  private async _updateAccounts(): Promise<void> {
    const { accounts } = this.state;
    const addresses = Object.keys(accounts);
    const chainId = this.getCurrentChainId();
    if (chainId === "loading") return;

    if (addresses.length > 0) {
      if (SINGLE_CALL_BALANCES_ADDRESSES[chainId]) {
        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESSES[chainId]);
        return;
      }
      log.info("falling back to ethQuery.getBalance");
      await Promise.all(addresses.map((x) => this._updateAccount(x)));
    }
  }

  private async _updateAccount(address: string): Promise<void> {
    const balance = await this.provider.request<[string, string], string>({ method: "eth_getBalance", params: [address, "latest"] });
    const { accounts } = this.state;
    if (!accounts[address]) return;
    accounts[address] = { balance: toQuantity(balance) };
    this.update({ accounts });
  }

  private async _updateAccountsViaBalanceChecker(addresses: string[], deployedContractAddress: string) {
    const ethContract = new Contract(deployedContractAddress, singleBalanceCheckerAbi, this.ethersProvider);
    try {
      const result: string[] = await ethContract.balances(addresses, [ZERO_ADDRESS]);
      const { accounts } = this.state;
      addresses.forEach((address, index) => {
        const balance = toQuantity(result[index]);
        if (!accounts[address]) return;
        accounts[address] = { balance };
      });
      return this.update({ accounts });
    } catch (error) {
      log.warn("Torus - Account Tracker single call balance fetch failed", error);
      return Promise.all(addresses.map((x) => this._updateAccount(x)));
    }
  }
}

export default AccountTrackerController;
