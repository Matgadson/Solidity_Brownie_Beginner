import { stripHexPrefix } from "@ethereumjs/util";
import {
  BasePreferencesController,
  CustomNft,
  CustomToken,
  IPreferencesController,
  PreferencesConfig,
  PreferencesState,
  TransactionStatus,
  UserInfo,
} from "@toruslabs/base-controllers";
import { get, patch, post, remove } from "@toruslabs/http-helpers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import { Mutex } from "async-mutex";
import log from "loglevel";

import PollingBlockTracker from "../Block/PollingBlockTracker";
import KeyringController from "../Keyring/KeyringController";
import NetworkController from "../Network/NetworkController";
import { SUPPORTED_NETWORKS } from "../utils/constants";
import { formatDate, formatPastTx, formatTime, getEthTxStatus } from "../utils/helpers";
import type {
  AddChainMessageParams,
  CustomNetworkPayload,
  CustomNetworks,
  CustomNftInfo,
  CustomTokenInfo,
  EthereumProviderConfig,
  EthereumUser,
  ExtendedAddressPreferences,
  FetchedTransaction,
  FormattedTransactionActivity,
  TransactionPayload,
} from "../utils/interfaces";

interface IPreferencesControllerOptions {
  config?: Partial<PreferencesConfig> & Pick<PreferencesConfig, "api" | "commonApiHost" | "signInPrefix">;
  state?: Partial<PreferencesState<ExtendedAddressPreferences>>;
  provider: SafeEventEmitterProvider;
  // TODO: Require later
  blockTracker?: PollingBlockTracker;
  signAuthMessage?: KeyringController["signAuthMessage"];
  getProviderConfig?: NetworkController["getProviderConfig"];
  setProviderConfig?: NetworkController["setProviderConfig"];
}

export default class PreferencesController
  extends BasePreferencesController<ExtendedAddressPreferences, PreferencesConfig, PreferencesState<ExtendedAddressPreferences>>
  implements IPreferencesController<ExtendedAddressPreferences, PreferencesConfig, PreferencesState<ExtendedAddressPreferences>>
{
  private _handle?: number;

  private _mutex: Mutex = new Mutex();

  private getProviderConfig: NetworkController["getProviderConfig"];

  private setProviderConfig: NetworkController["setProviderConfig"];

  private provider: SafeEventEmitterProvider;

  private blockTracker: PollingBlockTracker;

  constructor({ config, state, provider, blockTracker, signAuthMessage, getProviderConfig, setProviderConfig }: IPreferencesControllerOptions) {
    super({ config, state, defaultPreferences: { formattedPastTransactions: [], fetchedPastTx: [], paymentTx: [] }, signAuthMessage });
    this.provider = provider;
    this.getProviderConfig = getProviderConfig;
    this.setProviderConfig = setProviderConfig;
    this.blockTracker = blockTracker;
    log.info(this.blockTracker);
  }

  public async poll(interval?: number): Promise<void> {
    const releaseLock = await this._mutex.acquire();
    if (interval) this.configure({ pollInterval: interval });
    if (this._handle) window.clearTimeout(this._handle);
    // call here
    const storeSelectedAddress = this.state.selectedAddress;
    if (!storeSelectedAddress) return;
    if (!this.getAddressState(storeSelectedAddress)?.jwtToken) return;
    // This should never throw
    await this.sync(storeSelectedAddress);
    releaseLock();
    this._handle = window.setTimeout(() => {
      this.poll(this.config.pollInterval);
    }, this.config.pollInterval);
  }

  public async initPreferences(params: {
    address: string;
    jwtToken?: string;
    calledFromEmbed?: boolean;
    userInfo?: UserInfo;
    rehydrate?: boolean;
    locale?: string;
    type?: string;
    signatures?: string[];
    network?: string;
    web3AuthClientId?: string;
  }): Promise<void> {
    const { address, jwtToken, calledFromEmbed, userInfo, rehydrate, locale = "en-US", type, signatures, network, web3AuthClientId } = params;
    await super.init(address, userInfo, jwtToken, { type, email: userInfo.email, signatures, network });
    const { aggregateVerifier, verifier, verifierId } = userInfo || {};
    const userExists = await this.sync(address);
    if (!userExists) {
      const accountState = this.getAddressState(address);
      await this.createUser({
        selectedCurrency: accountState.selectedCurrency,
        theme: accountState.theme,
        verifier: aggregateVerifier || verifier,
        verifierId,
        locale,
        address,
      });
    }
    if (!rehydrate)
      await this.storeUserLogin({
        verifier: aggregateVerifier || verifier,
        verifierId,
        options: { calledFromEmbed, rehydrate },
        address,
        web3AuthClientId,
      });
  }

  public getSelectedAddress(): string {
    return this.state.selectedAddress;
  }

  async sync(address: string): Promise<boolean> {
    try {
      const user = await this.getUser<EthereumUser>(address);
      if (user) {
        const {
          default_currency: defaultCurrency,
          contacts,
          theme,
          locale,
          public_address: userPublicAddress,
          default_public_address: defaultPublicAddress,
          customNetworks,
          customTokens,
          customNfts,
        } = user || {};

        // update latest data in state.
        this.updateState(
          {
            contacts,
            theme,
            selectedCurrency: defaultCurrency,
            locale,
            defaultPublicAddress: defaultPublicAddress || userPublicAddress,
            customTokens,
            customNfts,
            customNetworks,
          },
          address
        );
        return true;
      }
      return false;
    } catch (error) {
      log.error(error);
      return false;
    } finally {
      Promise.all([
        this.getWalletOrders<FetchedTransaction>(address).catch((error) => {
          log.error("unable to fetch wallet orders", error);
        }),
      ])
        .then((data) => {
          const [walletTx] = data;
          // eslint-disable-next-line promise/always-return
          if (walletTx && walletTx.length > 0) {
            this.updateState({ fetchedPastTx: [...walletTx] }, address);
            this.calculatePastTx(walletTx, address);
          }
        })
        .catch((error) => log.error(error));
    }
  }

  public async patchNewTx(tx: TransactionPayload, address: string): Promise<void> {
    const formattedTx = formatPastTx(tx);
    const storePastTx = this.getAddressState(address)?.formattedPastTransactions;
    const duplicateIndex = storePastTx.findIndex((x) => x.transaction_hash === tx.transaction_hash && x.networkType === tx.network);
    if (tx.status === TransactionStatus.submitted || tx.status === TransactionStatus.confirmed) {
      if (duplicateIndex === -1) {
        // No duplicate found

        const finalTx = this.cancelTxCalculate([...storePastTx, formattedTx]);
        tx.is_cancel = formattedTx.is_cancel;
        tx.to = tx.to.toLowerCase();
        tx.from = tx.from.toLowerCase();

        this.updateState({ formattedPastTransactions: finalTx }, address);
        this.postPastTx<TransactionPayload>(tx, address);
      } else {
        // avoid overriding is_cancel
        formattedTx.is_cancel = storePastTx[duplicateIndex].is_cancel;
        storePastTx[duplicateIndex] = formattedTx;
        this.updateState({ formattedPastTransactions: this.cancelTxCalculate([...storePastTx]) }, address);
      }
    }
  }

  public recalculatePastTx(address?: string) {
    // This triggers store update which calculates past Tx status for that network
    const selectedAddress = address || this.state.selectedAddress;
    const state = this.getAddressState(selectedAddress);
    if (!state?.fetchedPastTx) return;
    this.calculatePastTx(state.fetchedPastTx, selectedAddress);
  }

  public async refetchEtherscanTx(address?: string) {
    const selectedAddress = address || this.state.selectedAddress;
    if (this.getAddressState(selectedAddress)?.jwtToken) {
      // const selectedNetwork = this.getProviderConfig().rpcTarget;
      // if (ETHERSCAN_SUPPORTED_NETWORKS.has(selectedNetwork)) {
      //   const data = await this.fetchEtherscanTx({ selectedAddress, selectedNetwork });
      //   if (data.length) {
      //     this.emit("addEtherscanTransactions", data, selectedNetwork);
      //   }
      // }
    }
  }

  async fetchEtherscanTx<T>(parameters: { selectedAddress: string; selectedNetwork: string }): Promise<T[]> {
    try {
      const url = new URL(`${this.config.api}/etherscan`);
      Object.keys(parameters).forEach((key) => url.searchParams.append(key, parameters[key as keyof typeof parameters]));
      const response = await get<{ success: boolean; data: T[] }>(url.href, this.headers(parameters.selectedAddress));
      return response.success ? response.data : [];
    } catch (error) {
      log.error("unable to fetch etherscan tx", error);
      return [];
    }
  }

  public async getEtherScanTokens(address: string, chainId: string): Promise<CustomTokenInfo[]> {
    const selectedAddress = address;
    const apiUrl = new URL(this.config.api);
    apiUrl.pathname = `/tokens`;
    apiUrl.searchParams.append("chainId", chainId);
    apiUrl.searchParams.append("address", selectedAddress);
    const result = await get<{ data: CustomTokenInfo[] }>(apiUrl.href, this.headers(this.state.selectedAddress));
    return result.data;
  }

  public async getSimpleHashNfts(address: string, chainId: string): Promise<CustomNftInfo[]> {
    const selectedAddress = address;
    const apiUrl = new URL(this.config.api);
    apiUrl.pathname = `/nfts`;
    apiUrl.searchParams.append("chainId", chainId);
    apiUrl.searchParams.append("address", selectedAddress);
    const result = await get<{ data: CustomNftInfo[] }>(apiUrl.href, this.headers(this.state.selectedAddress));
    return result.data;
  }

  public getCustomTokens(address?: string): CustomToken[] {
    return this.getAddressState(address)?.customTokens ?? [];
  }

  public getCustomNfts(address?: string): CustomNft[] {
    return this.getAddressState(address)?.customNfts ?? [];
  }

  public isChainIdSupported(address: string, chainId: string): boolean {
    const approveChainOptions = this.getChainOptions(address);
    const providerConfig = approveChainOptions.find((x) => stripHexPrefix(x.chainId) === chainId);
    return !!providerConfig;
  }

  public async addChain(network: AddChainMessageParams): Promise<void> {
    const approveChainOptions = this.getChainOptions();
    const providerConfig = approveChainOptions.find((x) => x.chainId === network.chainId);

    if (providerConfig) {
      throw new Error(`chainId ${network.chainId} already exists`);
    }

    const newNetwork: CustomNetworkPayload = {
      displayName: network.chainName,
      rpcTarget: network.rpcUrls[0],
      ticker: network.nativeCurrency.symbol,
      chainId: network.chainId,
      blockExplorerUrl: network.blockExplorerUrls[0],
    };

    const isSuccess = await this.addCustomNetwork({ type: "rpc", network: newNetwork });
    if (!isSuccess) throw new Error("unable to add custom network");
  }

  switchChain(data: { chainId: string }) {
    const chainOptions = this.getChainOptions();
    const providerConfig = chainOptions.find((x) => x.chainId === data.chainId);
    if (providerConfig) {
      this.setProviderConfig(providerConfig);
    } else {
      throw new Error(`chainId ${data.chainId} is not supported`);
    }
  }

  // Custom Network methods
  public async addCustomNetwork({ type, network }: { type: string; network: CustomNetworkPayload }): Promise<number> {
    try {
      const apiUrl = new URL(this.config.api);
      apiUrl.pathname = `/customnetwork/${type}`;
      const { selectedAddress } = this.state;
      const payload = {
        network_name: network.displayName,
        rpc_url: network.rpcTarget,
        chain_id: network.chainId,
        symbol: network.ticker,
        block_explorer_url: network.blockExplorerUrl || undefined,
        is_test_net: network.isTestnet || false,
      };
      const res = await post<{ data: CustomNetworks }>(apiUrl.href, payload, this.headers(selectedAddress), { useAPIKey: true });
      await this.sync(selectedAddress);

      return res.data.id;
    } catch {
      log.error("error adding custom network");
      return null;
    }
  }

  async deleteCustomNetwork(id: number) {
    try {
      const { selectedAddress } = this.state;
      const apiUrl = new URL(this.config.api);
      apiUrl.pathname = `/customnetwork/${id}`;
      await remove(apiUrl.href, {}, this.headers(selectedAddress), { useAPIKey: true });
      await this.sync(selectedAddress);
      return true;
    } catch {
      log.error("error deleting custom network");
      return false;
    }
  }

  async editCustomNetwork({ network, id }: { network: CustomNetworkPayload; id: number | null }) {
    try {
      const { selectedAddress } = this.state;
      const apiUrl = new URL(this.config.api);
      apiUrl.pathname = `/customnetwork/${id}`;

      const payload = {
        network_name: network.displayName,
        rpc_url: network.rpcTarget,
        chain_id: network.chainId,
        symbol: network.ticker || undefined,
        block_explorer_url: network.blockExplorerUrl || undefined,
        is_test_net: network.isTestnet || false,
      };
      await patch(apiUrl.href, payload, this.headers(selectedAddress), { useAPIKey: true });
      await this.sync(selectedAddress);
      return true;
    } catch {
      log.error("error editing custom network");
      return false;
    }
  }

  private getChainOptions(address: string = this.state.selectedAddress): EthereumProviderConfig[] {
    const { identities } = this.state;
    const customNetworks = identities[address]?.customNetworks ?? [];

    const custom: EthereumProviderConfig[] = Object.values(customNetworks).reduce((chains, network) => {
      const networkItem = {
        blockExplorerUrl: network.block_explorer_url,
        chainId: network.chain_id,
        displayName: network.network_name,
        logo: "eth.svg",
        rpcTarget: network.rpc_url,
        ticker: network.symbol,
        tickerName: network.symbol.toUpperCase(),
        isCustom: true,
        id: network.id,
      };
      if (Object.keys(SUPPORTED_NETWORKS).includes(networkItem.chainId)) return chains;
      chains.push(networkItem);
      return chains;
    }, []);

    const supported = Object.values(SUPPORTED_NETWORKS).reduce((chains, network) => {
      chains.push(network);
      return chains;
    }, []);

    return [...supported, ...custom];
  }

  private async calculatePastTx(txs: FetchedTransaction[], address: string) {
    const pastTx = [];
    const pendingTx = [];
    const lowerCaseSelectedAddress = address.toLowerCase();
    for (const x of txs) {
      if (
        x.network === SUPPORTED_NETWORKS[this.getProviderConfig().chainId].chainId &&
        x.to &&
        x.from &&
        (lowerCaseSelectedAddress === x.from.toLowerCase() || lowerCaseSelectedAddress === x.to.toLowerCase())
      ) {
        if (x.status !== "confirmed") {
          pendingTx.push(x);
        } else {
          const finalObject = formatPastTx(x, lowerCaseSelectedAddress);
          pastTx.push(finalObject);
        }
      }
    }
    const pendingTxPromises = pendingTx.map((x) => getEthTxStatus(x.transaction_hash, this.provider).catch((error) => log.error(error)));
    const resolvedTxStatuses = await Promise.all(pendingTxPromises);
    for (const [index, element] of pendingTx.entries()) {
      const finalObject = formatPastTx(element, lowerCaseSelectedAddress);
      finalObject.status = resolvedTxStatuses[index] || TransactionStatus.submitted;
      pastTx.push(finalObject);
      if (lowerCaseSelectedAddress === element.from.toLowerCase() && finalObject.status && finalObject.status !== element.status)
        this.patchPastTx({ id: element.id, status: finalObject.status, updated_at: new Date().toISOString() }, address);
    }

    const finalTx = this.cancelTxCalculate(pastTx);

    this.updateState({ formattedPastTransactions: [...finalTx] }, address);
  }

  private cancelTxCalculate(pastTx: FormattedTransactionActivity[]) {
    const nonceMap: Record<string, FormattedTransactionActivity[]> = {};
    for (const x of pastTx) {
      if (!nonceMap[x.nonce]) nonceMap[x.nonce] = [x];
      else {
        nonceMap[x.nonce].push(x);
      }
    }

    for (const [, value] of Object.entries(nonceMap)) {
      // has duplicate
      if (value.length > 1) {
        // get latest and mark it as is_cancel
        const latestTxs = value.sort((a, b) => {
          const aDate = new Date(a.date).getTime();
          const bDate = new Date(b.date).getTime();
          return bDate - aDate;
        });
        const latestCancelTx = latestTxs[0];
        latestCancelTx.is_cancel = true;
        latestTxs.slice(1).forEach((x) => {
          x.hasCancel = true;
          x.status = latestCancelTx.status === "confirmed" ? TransactionStatus.cancelled : TransactionStatus.cancelling;
          x.cancelDateInitiated = `${formatTime(new Date(latestCancelTx.date).getTime())} - ${formatDate(latestCancelTx.date)}`;
          x.etherscanLink = latestCancelTx.etherscanLink;
          x.cancelGas = latestCancelTx.gas;
          x.cancelGasPrice = latestCancelTx.gasPrice;
        });
      }
    }

    return pastTx;
  }
}
