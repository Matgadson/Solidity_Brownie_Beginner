import { BaseBlockTracker, PollingBlockTrackerConfig, timeout } from "@toruslabs/base-controllers";
import { BlockParams } from "ethers";
import log from "loglevel";

import { idleTimeTracker } from "../utils/helpers";
import { EthereumBlock, PollingBlockTrackerState } from "../utils/interfaces";

const DEFAULT_POLLING_INTERVAL = 20;
const DEFAULT_RETRY_TIMEOUT = 2;
const SEC = 1000;

class PollingBlockTracker extends BaseBlockTracker<EthereumBlock, PollingBlockTrackerConfig, PollingBlockTrackerState> {
  constructor({ config, state = {} }: { config: Partial<PollingBlockTrackerConfig>; state: Partial<PollingBlockTrackerState> }) {
    if (!config.provider) {
      throw new Error("PollingBlockTracker - no provider specified.");
    }

    super({ config, state });

    const pollingInterval = config.pollingInterval || DEFAULT_POLLING_INTERVAL;

    const retryTimeout = config.retryTimeout || DEFAULT_RETRY_TIMEOUT;

    // merge default + provided config.
    this.defaultConfig = {
      provider: config.provider,
      pollingInterval: pollingInterval * SEC,
      retryTimeout: retryTimeout * SEC,
      setSkipCacheFlag: config.setSkipCacheFlag || false,
    };

    this.initialize();
  }

  async checkForLatestBlock(): Promise<EthereumBlock> {
    await this._updateLatestBlock();
    return this.getLatestBlock();
  }

  // overrides the BaseBlockTracker._start method.
  protected _start(): void {
    this._synchronize().catch((err) => this.emit("error", err));
  }

  private async _synchronize(): Promise<void> {
    while (this.state._isRunning) {
      if (idleTimeTracker.checkIfIdle()) return;
      try {
        await this._updateLatestBlock();
        await timeout(this.config.pollingInterval);
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${(err as Error).stack}`);
        try {
          this.emit("error", newErr);
        } catch (emitErr) {
          log.error(newErr);
        }
        await timeout(this.config.retryTimeout);
      }
    }
  }

  private async _updateLatestBlock(): Promise<void> {
    // fetch + set latest block
    const latestBlock = await this._fetchLatestBlock();
    this._newPotentialLatest(latestBlock);
  }

  private async _fetchLatestBlock(): Promise<EthereumBlock> {
    try {
      const block = await this.config.provider.request<[string, boolean], { [K in keyof BlockParams]: string }>({
        method: "eth_getBlockByNumber",
        params: ["latest", false],
      });
      return {
        blockHash: block.hash,
        idempotencyKey: block.number,
        timestamp: block.timestamp,
        baseFeePerGas: block.baseFeePerGas,
        gasLimit: block.gasLimit,
      };
    } catch (error) {
      log.error("Polling Block Tracker: ", error);
      throw new Error(`PollingBlockTracker - encountered error fetching block:\n${(error as Error).message}`);
    }
  }
}

export default PollingBlockTracker;
