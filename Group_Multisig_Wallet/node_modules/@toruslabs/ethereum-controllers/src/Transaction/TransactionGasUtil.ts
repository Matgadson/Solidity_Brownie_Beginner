import { addHexPrefix, stripHexPrefix } from "@ethereumjs/util";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import { BN } from "bn.js";
import { cloneDeep } from "lodash";
import log from "loglevel";

import PollingBlockTracker from "../Block/PollingBlockTracker";
import { EthereumTransactionMeta, TransactionParams } from "../utils/interfaces";
export default class TransactionGasUtil {
  provider: SafeEventEmitterProvider;

  blockTracker: PollingBlockTracker;

  constructor(provider: SafeEventEmitterProvider, blockTracker: PollingBlockTracker) {
    this.provider = provider;
    this.blockTracker = blockTracker;
  }

  public async analyzeGasUsage(txMeta: EthereumTransactionMeta) {
    const block = await this.blockTracker.getLatestBlock();
    // fallback to block gasLimit
    const blockGasLimitBN = new BN(stripHexPrefix(block.gasLimit), 16);
    const saferGasLimitBN = blockGasLimitBN.mul(new BN(19)).div(new BN(20));
    let estimatedGasHex = addHexPrefix(saferGasLimitBN.toString("hex"));
    let simulationFails: Record<string, unknown>;

    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      log.warn(error);
      simulationFails = {
        reason: (error as Error).message,
        errorKey: (error as Error & { errorKey: string }).errorKey,
        debug: { blockNumber: block.idempotencyKey, blockGasLimit: block.gasLimit },
      };
    }
    return { blockGasLimit: block.gasLimit, estimatedGasHex, simulationFails };
  }

  /**
    Adds a gas buffer with out exceeding the block gas limit
  */
  public addGasBuffer(initialGasLimitHex: string, blockGasLimitHex: string, multiplier = 1.5): string {
    const initialGasLimitBn = new BN(stripHexPrefix(initialGasLimitHex), 16);
    const blockGasLimitBn = new BN(stripHexPrefix(blockGasLimitHex), 16);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);

    // if initialGasLimit is above blockGasLimit, dont modify it
    if (initialGasLimitBn.gt(upperGasLimitBn)) return addHexPrefix(initialGasLimitBn.toString("hex"));
    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit
    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return addHexPrefix(bufferedGasLimitBn.toString("hex"));
    // otherwise use blockGasLimit
    return addHexPrefix(upperGasLimitBn.toString("hex"));
  }

  /**
    Estimates the tx's gas usage
  */
  private async estimateTxGas(txMeta: EthereumTransactionMeta): Promise<string> {
    const txParams = cloneDeep(txMeta.transaction);

    // `eth_estimateGas` can fail if the user has insufficient balance for the
    // value being sent, or for the gas cost. We don't want to check their
    // balance here, we just want the gas estimate. The gas price is removed
    // to skip those balance checks. We check balance elsewhere. We also delete
    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.
    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas;

    return this.provider.request<[TransactionParams], string>({ method: "eth_estimateGas", params: [txParams] });
  }
}
