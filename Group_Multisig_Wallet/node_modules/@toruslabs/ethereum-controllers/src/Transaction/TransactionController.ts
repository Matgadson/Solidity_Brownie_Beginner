import { Common, Hardfork } from "@ethereumjs/common";
import { TransactionFactory, TypedTransaction } from "@ethereumjs/tx";
import { addHexPrefix, stripHexPrefix } from "@ethereumjs/util";
import { providerErrors, rpcErrors } from "@metamask/rpc-errors";
import {
  ITransactionController,
  TRANSACTION_TYPES,
  TransactionConfig,
  TransactionState,
  TransactionStatus,
  TX_CONFIRMED_EVENT_TYPE,
  TX_DROPPED_EVENT_TYPE,
  TX_EVENTS,
  TX_FAILED_EVENT_TYPE,
  TX_WARNING_EVENT_TYPE,
} from "@toruslabs/base-controllers";
import { JRPCRequest, SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import BigNumber from "bignumber.js";
import { keccak256 } from "ethers";
import log from "loglevel";

import PollingBlockTracker from "../Block/PollingBlockTracker";
import GasFeeController from "../Gas/GasFeeController";
import { type EthereumGasFeeEstimates, EthereumLegacyGasFeeEstimates } from "../Gas/IGasFeeController";
import KeyringController from "../Keyring/KeyringController";
import NetworkController from "../Network/NetworkController";
import PreferencesController from "../Preferences/PreferencesController";
import { CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP, GAS_ESTIMATE_TYPES, METHOD_TYPES, TRANSACTION_ENVELOPE_TYPES } from "../utils/constants";
import { decGWEIToHexWEI } from "../utils/conversionUtils";
import { bnLessThan, GAS_LIMITS, getChainType } from "../utils/helpers";
import {
  EthereumBlock,
  EthereumTransactionMeta,
  NonceLockRes,
  TransactionParams,
  TransactionReceipt,
  UserRequestApprovalParams,
} from "../utils/interfaces";
import NonceTracker from "./NonceTracker";
import PendingTransactionTracker from "./PendingTransactionTracker";
import TransactionGasUtil from "./TransactionGasUtil";
import TransactionStateManager from "./TransactionStateManager";
import { determineTransactionType, isEIP1559Transaction, normalizeTxParameters, validateTxParameters } from "./TransactionUtils";

export default class TransactionController extends TransactionStateManager implements ITransactionController<TransactionParams> {
  getSelectedAddress: PreferencesController["getSelectedAddress"];

  getEIP1559GasFeeEstimates: GasFeeController["fetchGasFeeEstimates"];

  public nonceTracker: NonceTracker;

  public pendingTxTracker: PendingTransactionTracker;

  public txGasUtil: TransactionGasUtil;

  private _getCurrentNetworkEIP1559Compatibility: NetworkController["getEIP1559Compatibility"];

  private _getCurrentAccountEIP1559Compatibility: (address?: string) => Promise<boolean>;

  private getProviderConfig: NetworkController["getProviderConfig"];

  private signEthTx: KeyringController["signTransaction"];

  private provider: SafeEventEmitterProvider;

  private blockTracker: PollingBlockTracker;

  private inProcessOfSigning: Set<string> = new Set();

  constructor({
    config,
    state,
    provider,
    blockTracker,
    signEthTx,
    getCurrentChainId,
    getCurrentNetworkEIP1559Compatibility,
    getProviderConfig,
    getCurrentAccountEIP1559Compatibility,
    getSelectedAddress,
    getEIP1559GasFeeEstimates,
  }: {
    config?: Partial<TransactionConfig>;
    state?: Partial<TransactionState<TransactionParams, EthereumTransactionMeta>>;
    provider: SafeEventEmitterProvider;
    blockTracker: PollingBlockTracker;
    signEthTx: KeyringController["signTransaction"];
    getCurrentChainId: NetworkController["getNetworkIdentifier"];
    getProviderConfig: NetworkController["getProviderConfig"];
    getCurrentNetworkEIP1559Compatibility: NetworkController["getEIP1559Compatibility"];
    getCurrentAccountEIP1559Compatibility: (address?: string) => Promise<boolean>; // used only if keyring supports EIP-1559
    getSelectedAddress: PreferencesController["getSelectedAddress"];
    getEIP1559GasFeeEstimates: GasFeeController["fetchGasFeeEstimates"];
  }) {
    super({ config, state, getCurrentChainId });
    this.blockTracker = blockTracker;
    this.getProviderConfig = getProviderConfig;
    this._getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
    this._getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
    this.getSelectedAddress = getSelectedAddress;
    this.getEIP1559GasFeeEstimates = getEIP1559GasFeeEstimates;
    this.signEthTx = signEthTx;
    this.provider = provider;
    this.txGasUtil = new TransactionGasUtil(this.provider, this.blockTracker);
    this.nonceTracker = new NonceTracker({
      provider,
      blockTracker,
      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),
      getPendingTransactions: this.getSubmittedTransactions.bind(this), // nonce tracker should only care about submitted transactions
    });
    this.pendingTxTracker = new PendingTransactionTracker({
      provider,
      nonceTracker: this.nonceTracker,
      getPendingTransactions: this.getPendingTransactions.bind(this), // pending tx tracker should only care about submitted and approved transactions
      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),
      approveTransaction: this.approveTransaction.bind(this),
      publishTransaction: (rawTx) => this.provider.request<[string], string>({ method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION, params: [rawTx] }),
    });
    this._setupListeners();
  }

  addTransactionUnapproved(txMeta: EthereumTransactionMeta) {
    this.addTransactionToState(txMeta);
    this.emit(`${txMeta.id}:unapproved`, txMeta);
  }

  async addNewUnapprovedTransaction(
    txParams: TransactionParams,
    req: JRPCRequest<TransactionParams> & UserRequestApprovalParams & { origin: string }
  ): Promise<string> {
    const txMeta = await this.createTransaction(txParams, req);
    return this.processApproval(txMeta);
  }

  async processApproval(txMeta: EthereumTransactionMeta): Promise<string> {
    return new Promise((resolve, reject) => {
      const handleFinished = (msg: EthereumTransactionMeta) => {
        if (msg.status === TransactionStatus.rejected) {
          return reject(providerErrors.userRejectedRequest(`Transaction Signature: User denied message signature`));
        }
        if (msg.status === TransactionStatus.failed) {
          return reject(rpcErrors.internal(`Transaction Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === TransactionStatus.submitted) {
          return resolve(msg.transactionHash);
        }

        return reject(rpcErrors.internal(`Transaction Signature: Unknown problem: ${JSON.stringify(txMeta.transaction)}`));
      };
      this.once(`${txMeta.id}:finished`, handleFinished);
    });
  }

  async approveTransaction(transactionID: string): Promise<void> {
    const txMeta = this.getTransaction(transactionID);
    if (this.inProcessOfSigning.has(transactionID)) {
      return;
    }
    this.inProcessOfSigning.add(transactionID);
    let nonceLock: NonceLockRes;
    try {
      this.setTxStatusApproved(transactionID);
      const fromAddress = txMeta.transaction.from;
      const { customNonceValue } = txMeta.transaction;
      const customNonceValueNumber = Number(customNonceValue);
      nonceLock = await this.nonceTracker.getNonceLock(fromAddress);
      // add nonce to txParams
      // if txMeta has previousGasParams then it is a retry at same nonce with
      // higher gas settings and therefor the nonce should not be recalculated
      const nonce = nonceLock.nextNonce;
      const customOrNonce = customNonceValueNumber === 0 ? customNonceValue : customNonceValue || nonce;
      txMeta.transaction.nonce = addHexPrefix(customOrNonce.toString(16));
      // add nonce debugging information to txMeta
      txMeta.nonceDetails = nonceLock.nonceDetails;
      this.updateTransactionInState(txMeta, "transactions#approveTransaction");
      // sign transaction
      const rawTx = await this.signTransaction(transactionID);
      await this.publishTransaction(transactionID, rawTx);
      nonceLock.releaseLock();
    } catch (err) {
      try {
        this.setTxStatusFailed(transactionID, err as Error);
      } catch (err2) {
        log.error(err2);
      }
      // must set transaction to submitted/failed before releasing lock
      if (nonceLock) {
        nonceLock.releaseLock();
      }
      // continue with error chain
      throw err;
    } finally {
      this.inProcessOfSigning.delete(transactionID);
    }
  }

  async signTransaction(txId: string): Promise<string> {
    const txMeta = this.getTransaction(txId);
    const chainId = this.getCurrentChainId();
    const type = isEIP1559Transaction(txMeta) ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;
    const txParams: TransactionParams = {
      ...txMeta.transaction,
      type,
      chainId,
      gasLimit: txMeta.transaction.gas,
    };
    const fromAddress = txParams.from;
    const common = await this.getCommonConfiguration(fromAddress);
    const unsignedEthTx = TransactionFactory.fromTxData(txParams, { common });
    const signedEthTx = await this.signEthTx<TypedTransaction, TypedTransaction>(unsignedEthTx, fromAddress);
    txMeta.r = addHexPrefix(signedEthTx.r.toString(16));
    txMeta.s = addHexPrefix(signedEthTx.s.toString(16));
    txMeta.v = addHexPrefix(signedEthTx.v.toString(16));
    this.updateTransactionInState(txMeta, "transactions#signTransaction: add r, s, v values");
    this.setTxStatusSigned(txId);
    const rawTx = addHexPrefix(Buffer.from(signedEthTx.serialize()).toString("hex"));
    return rawTx;
  }

  async publishTransaction(txId: string, rawTx: string): Promise<void> {
    const txMeta = this.getTransaction(txId);
    txMeta.rawTransaction = rawTx;
    this.updateTransactionInState(txMeta, "transactions#publishTransaction");
    let txHash: string;
    try {
      txHash = await this.provider.request<[string], string>({ method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION, params: [rawTx] });
    } catch (error) {
      if ((error as Error).message.toLowerCase().includes("known transaction")) {
        txHash = keccak256(addHexPrefix(rawTx));
        txHash = addHexPrefix(txHash);
      } else {
        throw error;
      }
    }
    this.setTxHash(txId, txHash);
    this.setTxStatusSubmitted(txId);
  }

  async confirmTransaction(params: TX_CONFIRMED_EVENT_TYPE): Promise<void> {
    const { txId, txReceipt } = params as TX_CONFIRMED_EVENT_TYPE & {
      baseFeePerGas?: string;
      blockTimestamp?: string;
      txReceipt: TransactionReceipt;
    };
    log.info(params, "confirm params");
    const txMeta = this.getTransaction(txId);
    if (!txMeta) return;
    try {
      txMeta.txReceipt = {
        ...txReceipt,
      };
      this.setTxStatusConfirmed(txId);
      this.markNonceDuplicatesDropped(txId);
      this.updateTransactionInState(txMeta, "transactions#confirmTransaction - add txReceipt");
    } catch (error) {
      log.error(error);
    }
  }

  cancelTransaction?(transactionID: string): Promise<void> {
    throw new Error(`Method not implemented. ${transactionID}`);
  }

  async getEIP1559Compatibility(fromAddress?: string) {
    const currentNetworkIsCompatible = await this._getCurrentNetworkEIP1559Compatibility();
    const fromAccountIsCompatible = await this._getCurrentAccountEIP1559Compatibility(fromAddress);
    return currentNetworkIsCompatible && fromAccountIsCompatible;
  }

  async addTransactionGasDefaults(txMeta: EthereumTransactionMeta) {
    let updateTxMeta = txMeta;
    try {
      updateTxMeta = await this.addTxGasDefaults(txMeta);
    } catch (error) {
      log.warn(error);
      updateTxMeta = this.getTransaction(txMeta.id);
      updateTxMeta.loadingDefaults = false;
      this.updateTransactionInState(txMeta, "Failed to calculate gas defaults.");
      throw error;
    }
    updateTxMeta.loadingDefaults = false;

    this.updateTransactionInState(updateTxMeta, "Added new unapproved transaction.");

    return updateTxMeta;
  }

  async addTxGasDefaults(txMeta: EthereumTransactionMeta) {
    const eip1559Compatibility = txMeta.transaction.type !== TRANSACTION_ENVELOPE_TYPES.LEGACY && (await this.getEIP1559Compatibility());

    const {
      gasPrice: defaultGasPrice,
      maxFeePerGas: defaultMaxFeePerGas,
      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas,
    } = await this.getDefaultGasFees(txMeta, eip1559Compatibility);
    const { gasLimit: defaultGasLimit, simulationFails } = await this.getDefaultGasLimit(txMeta);

    txMeta = this.getTransaction(txMeta.id);
    if (simulationFails) {
      txMeta.simulationFails = simulationFails;
    }

    if (eip1559Compatibility) {
      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.
      if (txMeta.transaction.gasPrice && !txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
        txMeta.transaction.maxFeePerGas = txMeta.transaction.gasPrice;
        // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
        // then we set maxFeePerGas to the suggested gasPrice.

        txMeta.transaction.maxPriorityFeePerGas = bnLessThan(
          typeof defaultMaxPriorityFeePerGas === "string" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas,
          typeof txMeta.transaction.gasPrice === "string" ? stripHexPrefix(txMeta.transaction.gasPrice) : txMeta.transaction.gasPrice
        )
          ? defaultMaxPriorityFeePerGas
          : txMeta.transaction.gasPrice;
      } else {
        if (defaultMaxFeePerGas && !txMeta.transaction.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.transaction.maxFeePerGas = defaultMaxFeePerGas;
        }

        if (defaultMaxPriorityFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.transaction.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
        }

        if (defaultGasPrice && !txMeta.transaction.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available
          // from the gasFeeController, then we set maxFeePerGas to the defaultGasPrice, assuming it is
          // available.
          txMeta.transaction.maxFeePerGas = defaultGasPrice;
        }

        if (txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is
          // available from the gasFeeController, then we set maxPriorityFeePerGas to
          // txMeta.transaction.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas
          // set by the dapp, or the maxFeePerGas from the controller.
          txMeta.transaction.maxPriorityFeePerGas = txMeta.transaction.maxFeePerGas;
        }
      }

      // We remove the gasPrice param entirely when on an eip1559 compatible network

      delete txMeta.transaction.gasPrice;
    } else {
      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params
      // when not on a EIP1559 compatible network

      delete txMeta.transaction.maxPriorityFeePerGas;
      delete txMeta.transaction.maxFeePerGas;
    }

    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are
    // set on transaction, it means that either we are on a non-EIP1559 network and the dapp didn't suggest
    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas
    // were available from either the dapp or the network.
    if (defaultGasPrice && !txMeta.transaction.gasPrice && !txMeta.transaction.maxPriorityFeePerGas && !txMeta.transaction.maxFeePerGas) {
      txMeta.transaction.gasPrice = defaultGasPrice;
    }

    if (defaultGasLimit && !txMeta.transaction.gas) {
      txMeta.transaction.gas = defaultGasLimit;
    }
    return txMeta;
  }

  setTxHash(txId: string, txHash: string) {
    // Add the tx hash to the persisted meta-tx object
    const txMeta = this.getTransaction(txId);
    txMeta.transactionHash = txHash;
    this.updateTransactionInState(txMeta, "transactions#setTxHash");
  }

  getUnapprovedTxCount = () => Object.keys(this.getUnapprovedTxList()).length;

  getPendingTxCount = (account?: string) => this.getPendingTransactions(account).length;

  async getDefaultGasFees(
    txMeta: EthereumTransactionMeta,
    eip1559Compatibility: boolean
  ): Promise<{ maxFeePerGas?: string; maxPriorityFeePerGas?: string; gasPrice?: string }> {
    if (
      (!eip1559Compatibility && txMeta.transaction.gasPrice) ||
      (eip1559Compatibility && txMeta.transaction.maxFeePerGas && txMeta.transaction.maxPriorityFeePerGas)
    ) {
      return {};
    }

    try {
      const { gasFeeEstimates, gasEstimateType } = await this.getEIP1559GasFeeEstimates();
      if (eip1559Compatibility && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {
        // this is in dec gwei
        const { medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {} } = <EthereumGasFeeEstimates>gasFeeEstimates;

        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
          return {
            // send to controller in hex wei
            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(new BigNumber(suggestedMaxFeePerGas)).toString(16)),
            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(new BigNumber(suggestedMaxPriorityFeePerGas)).toString(16)),
          };
        }
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {
        const { medium } = <EthereumLegacyGasFeeEstimates>gasFeeEstimates;
        // The LEGACY type includes low, medium and high estimates of
        // gas price values.
        return {
          gasPrice: addHexPrefix(decGWEIToHexWEI(new BigNumber(medium)).toString(16)),
        };
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
        const { gasPrice } = <{ gasPrice?: string }>gasFeeEstimates;
        // The ETH_GASPRICE type just includes a single gas price property,
        // which we can assume was retrieved from eth_gasPrice
        return {
          gasPrice: addHexPrefix(decGWEIToHexWEI(new BigNumber(gasPrice)).toString(16)),
        };
      }
    } catch (error) {
      log.error(error);
    }

    const gasPrice = await this.provider.request<never, string>({ method: METHOD_TYPES.ETH_GET_GAS_PRICE });

    return { gasPrice: gasPrice && addHexPrefix(gasPrice) };
  }

  private async getDefaultGasLimit(txMeta: EthereumTransactionMeta) {
    const chainId = this.getCurrentChainId();
    const customNetworkGasBuffer = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];
    const chainType = getChainType(chainId);

    if (txMeta.transaction.gas) {
      return {};
    }
    if (txMeta.transaction.to && txMeta.transactionCategory === TRANSACTION_TYPES.SENT_ETHER && chainType !== "custom" && !txMeta.transaction.data) {
      // This is a standard ether simple send, gas requirement is exactly 21k
      return { gasLimit: GAS_LIMITS.SIMPLE };
    }

    const { blockGasLimit, estimatedGasHex, simulationFails } = await this.txGasUtil.analyzeGasUsage(txMeta);

    // add additional gas buffer to our estimation for safety
    const gasLimit = this.txGasUtil.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit, customNetworkGasBuffer);
    return { gasLimit, simulationFails };
  }

  private async createTransaction(
    txParameters: TransactionParams,
    req: JRPCRequest<TransactionParams> & UserRequestApprovalParams
  ): Promise<EthereumTransactionMeta> {
    const normalizedTxParameters = normalizeTxParameters(txParameters);
    const eip1559Compatibility = await this.getEIP1559Compatibility(txParameters.from);
    validateTxParameters(normalizedTxParameters, eip1559Compatibility);

    let txMeta = this.generateTxMeta({
      transaction: normalizedTxParameters,
      origin: req.origin,
    });

    const { type, category, methodParams } = await determineTransactionType(txParameters, this.provider);
    txMeta.type = type;
    txMeta.transactionCategory = category;
    txMeta.methodParams = methodParams;
    txMeta.transaction.value = txMeta.transaction.value ? addHexPrefix(txMeta.transaction.value) : "0x0";
    this.emit(`${txMeta.id}:unapproved`, txMeta);
    txMeta = this.addTransactionToState(txMeta);
    txMeta = await this.addTransactionGasDefaults(txMeta);

    this.emit(TX_EVENTS.TX_UNAPPROVED, { txMeta, req });

    return txMeta;
  }

  private _setupListeners() {
    this.setupBlockTrackerListener();
    this.pendingTxTracker.on(TX_EVENTS.TX_WARNING, (data: TX_WARNING_EVENT_TYPE<TransactionParams, EthereumTransactionMeta>) => {
      this.updateTransactionInState(data.txMeta);
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_DROPPED, (data: TX_DROPPED_EVENT_TYPE) => this.setTxStatusDropped(data.txId));
    this.pendingTxTracker.on(
      TX_EVENTS.TX_BLOCK_UPDATE,
      ({ txMeta, latestBlockNumber }: { txMeta: EthereumTransactionMeta; latestBlockNumber: string; txId: string }) => {
        if (!txMeta.firstRetryBlockNumber) {
          txMeta.firstRetryBlockNumber = latestBlockNumber;
          this.updateTransactionInState(txMeta);
        }
      }
    );
    this.pendingTxTracker.on(TX_EVENTS.TX_RETRY, (txMeta) => {
      if (!("retryCount" in txMeta)) {
        txMeta.retryCount = 0;
      }
      txMeta.retryCount += 1;
      this.updateTransactionInState(txMeta);
    });

    this.pendingTxTracker.on(TX_EVENTS.TX_FAILED, (data: TX_FAILED_EVENT_TYPE) => {
      this.setTxStatusFailed(data.txId, data.error);
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_CONFIRMED, (data: TX_CONFIRMED_EVENT_TYPE) => this.confirmTransaction(data));
  }

  private setupBlockTrackerListener() {
    let listenersAreActive = false;
    const latestBlockHandler = this.onLatestBlock.bind(this);
    this.on(TX_EVENTS.TX_STATUS_UPDATE, () => {
      const pendingTxs = this.getPendingTransactions();
      if (!listenersAreActive && pendingTxs.length > 0) {
        this.blockTracker.on("latest", latestBlockHandler);
        listenersAreActive = true;
      } else if (listenersAreActive && !pendingTxs.length) {
        this.blockTracker.removeListener("latest", latestBlockHandler);
        listenersAreActive = false;
      }
    });
  }

  private async onLatestBlock(blockNumber: EthereumBlock) {
    try {
      await this.pendingTxTracker.updatePendingTxs();
    } catch (error) {
      log.error(error);
    }

    try {
      await this.pendingTxTracker.resubmitPendingTxs(blockNumber);
    } catch (error) {
      log.error(error);
    }
  }

  private async getCommonConfiguration(fromAddress: string) {
    const { chainId, displayName } = this.getProviderConfig();
    const supportsEIP1559 = await this.getEIP1559Compatibility(fromAddress);
    const hardfork = supportsEIP1559 ? Hardfork.Paris : Hardfork.Berlin;
    return Common.custom({
      chainId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
      defaultHardfork: hardfork,
      name: displayName,
      networkId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
    });
  }

  private markNonceDuplicatesDropped(txId: string) {
    const txMeta = this.getTransaction(txId);
    const { nonce, from } = txMeta.transaction;
    const sameNonceTxs = this.getTransactions({ searchCriteria: { from, nonce } });
    if (!sameNonceTxs.length) return;
    sameNonceTxs.forEach((tx) => {
      if (tx.id === txId) return;
      this.updateTransactionInState(txMeta, "transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce");
      if (tx.status !== TransactionStatus.failed) this.setTxStatusDropped(tx.id);
    });
  }
}
