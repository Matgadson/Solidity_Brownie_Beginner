// import assert from 'assert'
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import { Mutex, MutexInterface } from "async-mutex";

import PollingBlockTracker from "../Block/PollingBlockTracker";
import { METHOD_TYPES } from "../utils/constants";
import { EthereumTransactionMeta, Nonce, NonceDetails, NonceLockRes } from "../utils/interfaces";
import TransactionStateManager from "./TransactionStateManager";

interface INonceTrackerOptions {
  provider: SafeEventEmitterProvider;
  blockTracker: PollingBlockTracker;
  getPendingTransactions: TransactionStateManager["getPendingTransactions"];
  getConfirmedTransactions: TransactionStateManager["getConfirmedTransactions"];
}

class NonceTracker {
  private provider: SafeEventEmitterProvider;

  private blockTracker: PollingBlockTracker;

  private getPendingTransactions: TransactionStateManager["getPendingTransactions"];

  private getConfirmedTransactions: TransactionStateManager["getConfirmedTransactions"];

  private lockMap: Record<string, Mutex>;

  constructor({ provider, blockTracker, getPendingTransactions, getConfirmedTransactions }: INonceTrackerOptions) {
    this.provider = provider;
    this.blockTracker = blockTracker;
    this.getPendingTransactions = getPendingTransactions;
    this.getConfirmedTransactions = getConfirmedTransactions;
    this.lockMap = {};
  }

  public async getGlobalLock(): Promise<{ releaseLock: MutexInterface.Releaser }> {
    const globalMutex = this._lookupMutex("global");
    // await global mutex free
    const releaseLock = await globalMutex.acquire();
    return { releaseLock };
  }

  /**
    this will return an object with the `nextNonce` 
    `nonceDetails`, and the releaseLock.
    Note: releaseLock must be called after adding a signed tx 
    to pending transactions (or discarding).
  */
  public async getNonceLock(address: string): Promise<NonceLockRes> {
    // await global mutex free
    await this._globalMutexFree();
    // await lock free, then take lock
    const releaseLock = await this._takeMutex(address);
    try {
      // evaluate multiple nextNonce strategies
      const nonceDetails = {} as NonceDetails;
      const networkNonceResult = await this._getNetworkNextNonce(address);

      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address);
      const nextNetworkNonce = networkNonceResult.nonce;
      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed);

      const pendingTxs = this.getPendingTransactions(address);
      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested);

      nonceDetails.params = {
        highestLocallyConfirmed,
        highestSuggested,
        nextNetworkNonce,
      };
      nonceDetails.local = localNonceResult;
      nonceDetails.network = networkNonceResult;

      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce);

      // return nonce and release cb
      return { nextNonce, nonceDetails, releaseLock };
    } catch (error) {
      // release lock if we encounter an error
      releaseLock();
      throw error;
    }
  }

  private async _globalMutexFree() {
    const globalMutex = this._lookupMutex("global");
    const releaseLock = await globalMutex.acquire();
    releaseLock();
  }

  private async _takeMutex(lockId: string) {
    const mutex = this._lookupMutex(lockId);
    const releaseLock = await mutex.acquire();
    return releaseLock;
  }

  private _lookupMutex(lockId: string): Mutex {
    let mutex = this.lockMap[lockId];
    if (!mutex) {
      mutex = new Mutex();
      this.lockMap[lockId] = mutex;
    }
    return mutex;
  }

  private async _getNetworkNextNonce(address: string) {
    // calculate next nonce
    // we need to make sure our base count
    // and pending count are from the same block
    const block = await this.blockTracker.getLatestBlock();
    const baseCountStr = await this.provider.request<[string, string], string>({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,
      params: [address, block.idempotencyKey],
    });
    const baseCount = Number.parseInt(baseCountStr, 16);
    const nonceDetails = { block, baseCount };
    return { name: "network", nonce: baseCount, details: nonceDetails };
  }

  private _getHighestLocallyConfirmed(address: string): number {
    const confirmedTransactions = this.getConfirmedTransactions(address);
    const highest = this._getHighestNonce(confirmedTransactions);
    return Number.isInteger(highest) ? highest + 1 : 0;
  }

  private _getHighestNonce(txList: EthereumTransactionMeta[]): number {
    const nonces = txList.map((txMeta) => {
      const { nonce } = txMeta.transaction;
      return Number.parseInt(nonce, 16);
    });
    const highestNonce = Math.max.apply(null, nonces);
    return highestNonce;
  }

  private _getHighestContinuousFrom(txList: EthereumTransactionMeta[], startPoint: number): Nonce {
    const nonces = new Set(
      txList.map((txMeta) => {
        const { nonce } = txMeta.transaction;
        return Number.parseInt(nonce, 16);
      })
    );

    let highest = startPoint;
    while (nonces.has(highest)) {
      highest += 1;
    }

    return { name: "local", nonce: highest, details: { startPoint, highest } };
  }
}

export default NonceTracker;
