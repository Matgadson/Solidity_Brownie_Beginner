import {
  BASE_TX_EVENT_TYPE,
  ITransactionController,
  TransactionStatus,
  TX_CONFIRMED_EVENT_TYPE,
  TX_DROPPED_EVENT_TYPE,
  TX_EVENTS,
  TX_FAILED_EVENT_TYPE,
  TX_WARNING_EVENT_TYPE,
} from "@toruslabs/base-controllers";
import { SafeEventEmitter, SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import log from "loglevel";

import { METHOD_TYPES } from "../utils/constants";
import { EthereumBlock, EthereumTransactionMeta, TransactionParams, TransactionReceipt } from "../utils/interfaces";
import NonceTracker from "./NonceTracker";
import TransactionStateManager from "./TransactionStateManager";

export default class PendingTransactionTracker extends SafeEventEmitter {
  DROPPED_BUFFER_COUNT = 3;

  private nonceTracker: NonceTracker;

  private provider: SafeEventEmitterProvider;

  private approveTransaction: ITransactionController<EthereumTransactionMeta>["approveTransaction"];

  private droppedBlocksBufferByHash: Map<string, number>;

  private getConfirmedTransactions: TransactionStateManager["getConfirmedTransactions"];

  private getPendingTransactions: TransactionStateManager["getPendingTransactions"];

  private publishTransaction: (rawTx: string) => Promise<string>;

  constructor({
    provider,
    nonceTracker,
    approveTransaction,
    publishTransaction,
    getPendingTransactions,
    getConfirmedTransactions,
  }: {
    provider: SafeEventEmitterProvider;
    nonceTracker: NonceTracker;
    approveTransaction: ITransactionController<EthereumTransactionMeta>["approveTransaction"];
    publishTransaction: (rawTx: string) => Promise<string>;
    getPendingTransactions: TransactionStateManager["getPendingTransactions"];
    getConfirmedTransactions: TransactionStateManager["getConfirmedTransactions"];
  }) {
    super();
    this.provider = provider;
    this.nonceTracker = nonceTracker;
    this.approveTransaction = approveTransaction;
    this.publishTransaction = publishTransaction;
    this.getPendingTransactions = getPendingTransactions;
    this.getConfirmedTransactions = getConfirmedTransactions;
    this.droppedBlocksBufferByHash = new Map();
  }

  /**
    checks the network for signed txs and releases the nonce global lock if it is
  */
  public async updatePendingTxs(): Promise<void> {
    // in order to keep the nonceTracker accurate we block it while updating pending transactions
    const nonceGlobalLock = await this.nonceTracker.getGlobalLock();
    try {
      const pendingTxs = this.getPendingTransactions();
      await Promise.all(pendingTxs.map((txMeta) => this._checkPendingTx(txMeta)));
    } catch (error) {
      log.error("PendingTransactionTracker - Error updating pending transactions");
      log.error(error);
    }
    nonceGlobalLock.releaseLock();
  }

  public async resubmitPendingTxs(block: EthereumBlock) {
    const pending = this.getPendingTransactions();
    // only try resubmitting if their are transactions to resubmit
    if (pending.length === 0) return;
    // Keep this as a for loop because we want to wait for each item to be submitted
    for (const txMeta of pending) {
      try {
        await this._resubmitTx(txMeta, block.idempotencyKey);
      } catch (error: unknown) {
        /*
      Dont marked as failed if the error is a "known" transaction warning
      "there is already a transaction with the same sender-nonce
      but higher/same gas price"

      Also don't mark as failed if it has ever been broadcast successfully.
      A successful broadcast means it may still be mined.
      */
        const errorMessage = (error as { value: Error }).value?.message?.toLowerCase() || (error as Error).message.toLowerCase();
        const isKnownTx =
          // geth
          errorMessage.includes("replacement transaction underpriced") ||
          errorMessage.includes("known transaction") ||
          // parity
          errorMessage.includes("gas price too low to replace") ||
          errorMessage.includes("transaction with the same hash was already imported") ||
          // other
          errorMessage.includes("gateway timeout") ||
          errorMessage.includes("nonce too low");
        // ignore resubmit warnings, return early
        if (isKnownTx) return;
        // encountered real error - transition to error state
        txMeta.warning = {
          error: errorMessage,
          message: "There was an error when resubmitting this transaction.",
        };
        this.emit(TX_EVENTS.TX_WARNING, { txMeta, error, txId: txMeta.id } as TX_WARNING_EVENT_TYPE<TransactionParams, EthereumTransactionMeta>);
      }
    }
  }

  async _resubmitTx(txMeta: EthereumTransactionMeta, latestBlockNumber?: string) {
    if (!txMeta.firstRetryBlockNumber) {
      this.emit(TX_EVENTS.TX_BLOCK_UPDATE, { txMeta, latestBlockNumber, txId: txMeta.id } as BASE_TX_EVENT_TYPE);
    }

    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber;
    const txBlockDistance = Number.parseInt(latestBlockNumber, 16) - Number.parseInt(firstRetryBlockNumber, 16);

    const retryCount = txMeta.retryCount || 0;

    // Exponential backoff to limit retries at publishing (capped at last 15 mins)
    if (txBlockDistance <= Math.min(50, 2 ** retryCount)) return undefined;

    // Only auto-submit already-signed txs:
    if (!("rawTx" in txMeta)) return this.approveTransaction(txMeta.id);

    const { rawTx } = txMeta;
    const txHash = await this.publishTransaction(rawTx as string);

    // Increment successful tries:
    this.emit(TX_EVENTS.TX_RETRY, { txMeta, txId: txMeta.id } as BASE_TX_EVENT_TYPE);
    return txHash;
  }

  async _checkPendingTx(foundTx: EthereumTransactionMeta): Promise<void> {
    const txMeta = foundTx;
    const txHash = txMeta.transactionHash;
    const txId = txMeta.id;

    // Only check submitted txs
    if (txMeta.status !== TransactionStatus.submitted) return;

    // extra check in case there was an uncaught error during the
    // signature and submission process
    if (!txHash) {
      const noTxHashError = new Error("We had an error while submitting this transaction, please try again.");
      noTxHashError.name = "NoTxHashError";
      this.emit(TX_EVENTS.TX_FAILED, { txId, error: noTxHashError } as TX_FAILED_EVENT_TYPE);
      return;
    }

    // If another tx with the same nonce is mined, set as failed.
    if (this._checkIfNonceIsTaken(txMeta)) {
      this.emit(TX_EVENTS.TX_DROPPED, { txId } as TX_DROPPED_EVENT_TYPE);
      return;
    }

    try {
      const transactionReceipt = await this.provider.request<[string], TransactionReceipt>({
        method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,
        params: [txHash],
      });
      if (transactionReceipt?.blockNumber) {
        const { baseFeePerGas, timestamp } = await this.provider.request<[string, boolean], EthereumBlock>({
          method: METHOD_TYPES.ETH_GET_BLOCK_BY_HASH,
          params: [transactionReceipt.blockHash, false],
        });
        this.emit(TX_EVENTS.TX_CONFIRMED, {
          txId,
          txReceipt: transactionReceipt,
          baseFeePerGas,
          blockTimestamp: timestamp,
        } as TX_CONFIRMED_EVENT_TYPE);
        return;
      }
    } catch (error) {
      log.error("error while loading tx", error);
      txMeta.warning = {
        error: (error as Error).message,
        message: "There was a problem loading this transaction.",
      };
      this.emit(TX_EVENTS.TX_WARNING, { txMeta } as TX_WARNING_EVENT_TYPE<TransactionParams, EthereumTransactionMeta>);
    }

    if (await this._checkIfTxWasDropped(txMeta)) {
      this.emit(TX_EVENTS.TX_DROPPED, { txId } as TX_DROPPED_EVENT_TYPE);
    }
  }

  async _checkIfTxWasDropped(txMeta: EthereumTransactionMeta): Promise<boolean> {
    const {
      transactionHash: txHash,
      transaction: { nonce, from },
    } = txMeta;
    const networkNextNonce = await this.provider.request<[string, string], string>({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,
      params: [from, "latest"],
    });

    if (Number.parseInt(nonce, 16) >= Number.parseInt(networkNextNonce, 16)) {
      return false;
    }

    if (!this.droppedBlocksBufferByHash.has(txHash)) {
      this.droppedBlocksBufferByHash.set(txHash, 0);
    }

    const currentBlockBuffer = this.droppedBlocksBufferByHash.get(txHash);

    if (currentBlockBuffer < this.DROPPED_BUFFER_COUNT) {
      this.droppedBlocksBufferByHash.set(txHash, currentBlockBuffer + 1);
      return false;
    }

    this.droppedBlocksBufferByHash.delete(txHash);
    return true;
  }

  _checkIfNonceIsTaken(txMeta: EthereumTransactionMeta) {
    const address = txMeta.transaction.from;
    const completed = this.getConfirmedTransactions(address);
    return completed.some((otherMeta) => {
      if (otherMeta.id === txMeta.id) {
        return false;
      }
      return otherMeta.transaction.nonce === txMeta.transaction.nonce;
    });
  }
}
