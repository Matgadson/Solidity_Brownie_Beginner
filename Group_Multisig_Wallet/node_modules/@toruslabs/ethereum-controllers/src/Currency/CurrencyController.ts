import { BaseCurrencyController, BaseCurrencyControllerConfig, BaseCurrencyControllerState } from "@toruslabs/base-controllers";
import { get } from "@toruslabs/http-helpers";
import log from "loglevel";

import { idleTimeTracker } from "../utils/helpers";
import { EthereumNetworkState } from "../utils/interfaces";

export interface IEthereumCurrencyControllerState extends BaseCurrencyControllerState {
  commonDenomination: string;
  commonDenominatorPrice: number;
}

export default class CurrencyController extends BaseCurrencyController<BaseCurrencyControllerConfig, IEthereumCurrencyControllerState> {
  private conversionInterval: number;

  constructor({
    config,
    state,
    onNetworkChanged,
  }: {
    config: Partial<BaseCurrencyControllerConfig>;
    state: Partial<IEthereumCurrencyControllerState>;
    onNetworkChanged: (listener: (networkState: EthereumNetworkState) => void) => void;
  }) {
    super({ config, state });
    this.defaultState = {
      ...this.defaultState,
      commonDenomination: "USD",
      commonDenominatorPrice: 0,
    };
    this.initialize();
    onNetworkChanged((networkState) => {
      // to be called as (listener) => this.networkController.on('networkDidChange', listener);
      if (networkState.providerConfig.ticker.toUpperCase() !== this.state.nativeCurrency.toUpperCase()) {
        this.setNativeCurrency(networkState.providerConfig.ticker);
        this.updateConversionRate();
      }
    });
  }

  public setCommonDenomination(commonDenomination: string): void {
    this.update({ commonDenomination });
  }

  public getCommonDenomination(): string {
    return this.state.commonDenomination;
  }

  public setCommonDenominatorPrice(commonDenominatorPrice: number): void {
    this.update({ commonDenominatorPrice });
  }

  public getCommonDenominatorPrice(): number {
    return this.state.commonDenominatorPrice;
  }

  /**
   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
   * previous interval is clear and a new one is created.
   */
  public scheduleConversionInterval(): void {
    if (this.conversionInterval) {
      window.clearInterval(this.conversionInterval);
    }
    this.conversionInterval = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.updateConversionRate();
      }
    }, this.config.pollInterval);
  }

  /**
   * Updates the conversionRate and conversionDate properties associated with the currentCurrency. Updated info is
   * fetched from an external API
   */
  public async updateConversionRate() {
    const currentCurrency = this.getCurrentCurrency();
    const nativeCurrency = this.getNativeCurrency();
    const commonDenomination = this.getCommonDenomination();
    const conversionRate = await this.retrieveConversionRate(nativeCurrency, currentCurrency, commonDenomination);

    const currentCurrencyRate = Number.parseFloat(conversionRate[currentCurrency.toUpperCase()]);
    const commonDenominationRate = Number.parseFloat(conversionRate[commonDenomination.toUpperCase()]);
    // set conversion rate
    if (currentCurrencyRate || commonDenominationRate) {
      // ETC
      this.setConversionRate(currentCurrencyRate);
      this.setConversionDate(Math.floor(Date.now() / 1000).toString());
      if (currentCurrency.toUpperCase() === commonDenomination.toUpperCase()) {
        this.setCommonDenominatorPrice(currentCurrencyRate);
      } else {
        this.setCommonDenominatorPrice(commonDenominationRate);
      }
    } else {
      this.setConversionRate(0);
      this.setConversionDate("N/A");
    }
  }

  private async retrieveConversionRate(fromCurrency: string, toCurrency: string, commonDenomination: string): Promise<Record<string, string>> {
    try {
      // query cryptocompare
      let apiUrl = `${this.config.api}/currency?fsym=${fromCurrency.toUpperCase()}&tsyms=${toCurrency.toUpperCase()}`;
      if (commonDenomination && commonDenomination.toUpperCase() !== toCurrency.toUpperCase()) {
        apiUrl += `,${commonDenomination.toUpperCase()}`;
      }
      const parsedResponse = await get<Record<string, string>>(apiUrl);

      return parsedResponse;
    } catch (error) {
      log.error(error, `CurrencyController - updateCommonDenominatorPrice: Failed to query rate for currency: ${fromCurrency}/ ${toCurrency}`);
    }

    return { [toCurrency.toUpperCase()]: "0", [commonDenomination.toUpperCase()]: "0" };
  }
}
