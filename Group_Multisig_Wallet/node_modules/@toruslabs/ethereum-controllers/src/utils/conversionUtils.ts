// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/* Currency Conversion Utility
 * This utility function can be used for converting currency related values within metamask.
 * The caller should be able to pass it a value, along with information about the value's
 * numeric base, denomination and currency, and the desired numeric base, denomination and
 * currency. It should return a single value.
 *
 * @param {(number | string | BN)} value - The value to convert.
 * @param {Object} [options] - Options to specify details of the conversion
 * @param {string} [options.fromCurrency = 'ETH' | 'USD'] - The currency of the passed value
 * @param {string} [options.toCurrency = 'ETH' | 'USD'] - The desired currency of the result
 * @param {string} [options.fromNumericBase = 'hex' | 'dec' | 'BN'] - The numeric basic of the passed value.
 * @param {string} [options.toNumericBase = 'hex' | 'dec' | 'BN'] - The desired numeric basic of the result.
 * @param {string} [options.fromDenomination = 'WEI'] - The denomination of the passed value
 * @param {string} [options.numberOfDecimals] - The desired number of decimals in the result
 * @param {string} [options.roundDown] - The desired number of decimals to round down to
 * @param {number} [options.conversionRate] - The rate to use to make the fromCurrency -> toCurrency conversion
 * @returns {(number | string | BN)}
 *
 * The utility passes value along with the options as a single object to the `converter` function.
 * `converter` conditional modifies the supplied `value` property, depending
 * on the accompanying options.
 */

import { stripHexPrefix } from "@ethereumjs/util";
import BigNumber from "bignumber.js";
import BN from "bn.js";

// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new BigNumber("1000000000000000000");
const BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber("1000000000");
const BIG_NUMBER_ETH_MULTIPLIER = new BigNumber("1");

type NumericBase = "hex" | "dec" | "BN";

type EthDenomination = "WEI" | "GWEI" | "ETH";

type ConverterOptions = {
  value: BigNumber | string;
  fromNumericBase: NumericBase;
  fromDenomination: EthDenomination;
  fromCurrency: string;
  toNumericBase: NumericBase;
  toDenomination: EthDenomination;
  toCurrency: string;
  numberOfDecimals: number;
  conversionRate: number;
  invertConversionRate: boolean;
  roundDown?: number;
};

// Setter Maps
const toBigNumber = {
  hex: (n) => new BigNumber(stripHexPrefix(n), 16),
  dec: (n) => new BigNumber(String(n), 10),
  BN: (n) => new BigNumber(n.toString(16), 16),
};
const toNormalizedDenomination = {
  WEI: (bigNumber) => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: (bigNumber) => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: (bigNumber) => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER),
};
const toSpecifiedDenomination = {
  WEI: (bigNumber) => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),
  GWEI: (bigNumber) => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),
  ETH: (bigNumber) => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),
};
const baseChange = {
  hex: (n) => n.toString(16),
  dec: (n) => new BigNumber(n).toString(10),
  BN: (n) => new BN(n.toString(16)),
};

// Utility function for checking base types
const isValidBase = (base) => Number.isInteger(base) && base > 1;

/**
 * Utility method to convert a value between denominations, formats and currencies.
 */
const converter = ({
  value,
  fromNumericBase,
  fromDenomination,
  fromCurrency,
  toNumericBase,
  toDenomination,
  toCurrency,
  numberOfDecimals,
  conversionRate,
  invertConversionRate,
  roundDown,
}: ConverterOptions) => {
  let convertedValue = fromNumericBase ? toBigNumber[fromNumericBase](value) : value;

  if (fromDenomination) {
    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
  }

  if (fromCurrency !== toCurrency) {
    if (conversionRate === null || conversionRate === undefined) {
      throw new Error(`Converting from ${fromCurrency} to ${toCurrency} requires a conversionRate, but one was not provided`);
    }
    let rate = toBigNumber.dec(conversionRate);
    if (invertConversionRate) {
      rate = new BigNumber(1).div(conversionRate);
    }
    convertedValue = convertedValue.times(rate);
  }

  if (toDenomination) {
    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
  }

  if (numberOfDecimals) {
    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);
  }

  if (roundDown) {
    convertedValue = convertedValue.dp(roundDown, BigNumber.ROUND_DOWN);
  }

  if (toNumericBase) {
    convertedValue = baseChange[toNumericBase](convertedValue);
  }
  return convertedValue;
};

export const conversionUtil = (
  value: BigNumber | string,
  {
    fromCurrency = null,
    toCurrency = fromCurrency,
    fromNumericBase,
    toNumericBase,
    fromDenomination,
    toDenomination,
    numberOfDecimals,
    conversionRate,
    invertConversionRate,
  }: Omit<ConverterOptions, "value">
) => {
  if (fromCurrency !== toCurrency && !conversionRate) {
    return 0;
  }
  return converter({
    fromCurrency,
    toCurrency,
    fromNumericBase,
    toNumericBase,
    fromDenomination,
    toDenomination,
    numberOfDecimals,
    conversionRate,
    invertConversionRate,
    value,
  });
};

export const getBigNumber = (value, base) => {
  if (!isValidBase(base)) {
    throw new Error("Must specificy valid base");
  }

  // We don't include 'number' here, because BigNumber will throw if passed
  // a number primitive it considers unsafe.
  if (typeof value === "string" || value instanceof BigNumber) {
    return new BigNumber(value, base);
  }

  return new BigNumber(String(value), base);
};

export const addCurrencies = (a, b, options: Record<string, unknown> = {}) => {
  const { aBase, bBase, ...conversionOptions } = options;

  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error("Must specify valid aBase and bBase");
  }

  const value = getBigNumber(a, aBase).plus(getBigNumber(b, bBase));

  return converter({
    value,
    ...conversionOptions,
  } as ConverterOptions);
};

export const subtractCurrencies = (a, b, options: Record<string, unknown> = {}) => {
  const { aBase, bBase, ...conversionOptions } = options;

  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error("Must specify valid aBase and bBase");
  }

  const value = getBigNumber(a, aBase).minus(getBigNumber(b, bBase));

  return converter({
    value,
    ...conversionOptions,
  } as ConverterOptions);
};

export const multiplyCurrencies = (a, b, options: Record<string, unknown> = {}) => {
  const { multiplicandBase, multiplierBase, ...conversionOptions } = options;

  if (!isValidBase(multiplicandBase) || !isValidBase(multiplierBase)) {
    throw new Error("Must specify valid multiplicandBase and multiplierBase");
  }

  const value = getBigNumber(a, multiplicandBase).times(getBigNumber(b, multiplierBase));

  return converter({
    value,
    ...conversionOptions,
  } as ConverterOptions);
};

export const conversionGreaterThan = ({ ...firstProps }: ConverterOptions, { ...secondProps }: ConverterOptions) => {
  const firstValue = converter({ ...firstProps });
  const secondValue = converter({ ...secondProps });

  return firstValue.gt(secondValue);
};

export const conversionLessThan = ({ ...firstProps }: ConverterOptions, { ...secondProps }: ConverterOptions) => {
  const firstValue = converter({ ...firstProps });
  const secondValue = converter({ ...secondProps });

  return firstValue.lt(secondValue);
};

export const conversionMax = ({ ...firstProps }, { ...secondProps }) => {
  const firstIsGreater = conversionGreaterThan({ ...firstProps }, { ...secondProps });

  return firstIsGreater ? firstProps.value : secondProps.value;
};

export const conversionGTE = ({ ...firstProps }, { ...secondProps }) => {
  const firstValue = converter({ ...firstProps } as ConverterOptions);
  const secondValue = converter({ ...secondProps } as ConverterOptions);
  return firstValue.isGreaterThanOrEqualTo(secondValue);
};

export const conversionLTE = ({ ...firstProps }, { ...secondProps }) => {
  const firstValue = converter({ ...firstProps } as ConverterOptions);
  const secondValue = converter({ ...secondProps } as ConverterOptions);
  return firstValue.isLessThanOrEqualTo(secondValue);
};

export const toNegative = (n, options = {}) => multiplyCurrencies(n, -1, options);

export const decGWEIToHexWEI = (decGWEI: BigNumber): BigNumber => {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI",
  } as ConverterOptions);
};

export const hexWEIToDecGWEI = (decGWEI: BigNumber | string): BigNumber => {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI",
  } as ConverterOptions);
};
