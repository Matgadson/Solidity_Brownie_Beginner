import { addHexPrefix, isValidAddress, toChecksumAddress } from "@ethereumjs/util";
import {
  ACTIVITY_ACTION_RECEIVE,
  ACTIVITY_ACTION_SEND,
  addressSlicer,
  formatSmallNumbers,
  significantDigits,
  TransactionStatus,
} from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import BigNumber from "bignumber.js";
import log from "loglevel";

import {
  CONTRACT_TYPE_ERC20,
  CONTRACT_TYPE_ERC721,
  CONTRACT_TYPE_ERC1155,
  MAINNET_CHAIN_ID,
  METHOD_TYPES,
  SUPPORTED_NETWORKS,
  TEST_CHAINS,
} from "./constants";
import { FormattedTransactionActivity, TransactionPayload, TransactionReceipt } from "./interfaces";

export function getEtherScanHashLink(txHash: string, chainId: string) {
  if (!SUPPORTED_NETWORKS[chainId]) return "";
  return `${SUPPORTED_NETWORKS[chainId].blockExplorerUrl}/tx/${txHash}`;
}

export const formatPastTx = (x: TransactionPayload, lowerCaseSelectedAddress?: string): FormattedTransactionActivity => {
  let totalAmountString = "";
  if (x.type === CONTRACT_TYPE_ERC721 || x.type === CONTRACT_TYPE_ERC1155) totalAmountString = x.symbol;
  else if (x.type === CONTRACT_TYPE_ERC20) totalAmountString = formatSmallNumbers(Number.parseFloat(x.total_amount), x.symbol, true);
  else totalAmountString = formatSmallNumbers(Number.parseFloat(x.total_amount), x.type_name, true);
  const currencyAmountString =
    x.type === CONTRACT_TYPE_ERC721 || x.type === CONTRACT_TYPE_ERC1155
      ? ""
      : formatSmallNumbers(Number.parseFloat(x.currency_amount), x.selected_currency, true);
  const finalObject: FormattedTransactionActivity = {
    id: x.created_at.toString(),
    date: new Date(x.created_at).toString(),
    from: x.from,
    from_aa_address: x.from_aa_address,
    slicedFrom: typeof x.from === "string" ? addressSlicer(x.from) : "",
    to: x.to,
    slicedTo: typeof x.to === "string" ? addressSlicer(x.to) : "",
    action: lowerCaseSelectedAddress === x.to?.toLowerCase() || "" ? ACTIVITY_ACTION_RECEIVE : ACTIVITY_ACTION_SEND,
    totalAmount: x.total_amount,
    totalAmountString,
    currencyAmount: x.currency_amount,
    currencyAmountString,
    amount: `${totalAmountString} / ${currencyAmountString}`,
    status: x.status,
    etherscanLink: getEtherScanHashLink(x.transaction_hash, x.network || MAINNET_CHAIN_ID),
    networkType: x.network,
    ethRate:
      Number.parseFloat(x?.total_amount) && Number.parseFloat(x?.currency_amount)
        ? `1 ${x.symbol} = ${significantDigits(Number.parseFloat(x.currency_amount) / Number.parseFloat(x.total_amount))}`
        : "",
    currencyUsed: x.selected_currency,
    type: x.type,
    type_name: x.type_name,
    type_image_link: x.type_image_link,
    transaction_hash: x.transaction_hash,
    transaction_category: x.transaction_category,
    // TODO: // figure out how to handle these values.
    // isEtherscan: x.isEtherscan,
    // input: x.input || "",
    // token_id: x.token_id || "",
    contract_address: x.contract_address || "",
    nonce: x.nonce || "",
    is_cancel: !!x.is_cancel || false,
    gas: x.gas || "",
    gasPrice: x.gasPrice || "",
  };
  return finalObject;
};

/**
 * Ref - https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt
 */
export const getEthTxStatus = async (hash: string, provider: SafeEventEmitterProvider): Promise<TransactionStatus | undefined> => {
  try {
    const result = await provider.request<[string], TransactionReceipt>({ method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT, params: [hash] });
    if (result === null) return TransactionStatus.submitted;
    if (result && result.status === "0x1") return TransactionStatus.confirmed;
    if (result && result.status === "0x0") return TransactionStatus.rejected;
    return undefined;
  } catch (err) {
    log.warn("unable to fetch transaction status", err);
    return undefined;
  }
};

export function formatDate(inputDate: string) {
  const monthList = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const date = new Date(inputDate);
  const day = date.getDate();
  const month = monthList[date.getMonth()];
  const year = date.getFullYear();
  return `${day} ${month} ${year}`;
}

export function formatTime(time: number) {
  return new Date(time).toTimeString().slice(0, 8);
}

export const idleTimeTracker = ((activityThresholdTime: number): { checkIfIdle: () => boolean } => {
  let isIdle = false;
  let idleTimeout: number = null;

  const resetTimer = () => {
    if (idleTimeout) {
      window.clearTimeout(idleTimeout);
    }
    isIdle = false;
    idleTimeout = window.setTimeout(() => {
      isIdle = true;
    }, activityThresholdTime * 1000);
  };

  window.addEventListener("load", resetTimer);
  document.addEventListener("mousemove", resetTimer);
  document.addEventListener("keydown", resetTimer);

  function checkIfIdle() {
    return isIdle;
  }
  return {
    checkIfIdle,
  };
})(60 * 3);

export function isAddressByChainId(address: string, _chainId: string) {
  // TOOD: add rsk network checks.
  return isValidAddress(address);
}

export function toChecksumAddressByChainId(address: string, chainId: string) {
  // TOOD: add rsk network checks.
  if (!isAddressByChainId(address, chainId)) return address;
  return toChecksumAddress(address);
}

export const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: addHexPrefix((21_000).toString(16)),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: addHexPrefix((100_000).toString(16)),
};

export function bnLessThan(a: string | number, b: string | number) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new BigNumber(a, 10).lt(b, 10);
}

export const getIpfsEndpoint = (path: string) => `https://infura-ipfs.io/${path}`;

export function sanitizeNftMetdataUrl(url: string): string {
  let finalUri = url;
  if (url?.startsWith("ipfs")) {
    const ipfsPath = url.split("ipfs://")[1];
    finalUri = getIpfsEndpoint(ipfsPath);
  }
  return finalUri;
}

export function getChainType(chainId: string) {
  if (chainId === MAINNET_CHAIN_ID) {
    return "mainnet";
  } else if ((TEST_CHAINS as string[]).includes(chainId)) {
    return "testnet";
  }
  return "custom";
}
