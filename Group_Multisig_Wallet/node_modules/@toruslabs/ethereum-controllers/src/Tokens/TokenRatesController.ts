import { BaseConfig, BaseController, BaseState, PreferencesState } from "@toruslabs/base-controllers";
import { get } from "@toruslabs/http-helpers";
import log from "loglevel";

import { COINGECKO_PLATFORMS_CHAIN_CODE_MAP, COINGECKO_SUPPORTED_CURRENCIES } from "../utils/constants";
import { idleTimeTracker } from "../utils/helpers";
import { CustomTokenInfo, EthereumNetworkState, ExtendedAddressPreferences } from "../utils/interfaces";
import { TokensControllerState } from "./ITokensController";

export interface CoinGeckoResponse {
  [address: string]: {
    [currency: string]: number;
  };
}

type ContractExchangeRates = Record<string, number | undefined>;

export const DEFAULT_CURRENCY = "eth";

export interface ITokenRatesControllerState extends BaseState {
  contractExchangeRates: ContractExchangeRates;
}

export interface ITokenRatesControllerConfig extends BaseConfig {
  pollInterval: number;
  api: string;
  currencyApi: string;
  chainId: string;
  selectedAddress: string;
  nativeCurrency: string;
  tokens: CustomTokenInfo[];
}

export interface TokenRatesControllerOptions {
  config: Partial<ITokenRatesControllerConfig>;
  state: Partial<ITokenRatesControllerState>;
  onPreferencesStateChange: (listener: (preferencesState: PreferencesState<ExtendedAddressPreferences>) => void) => void;
  onTokensStateChange: (listener: (tokensState: TokensControllerState) => void) => void;
  onNetworkStateChange: (listener: (networkState: EthereumNetworkState) => void) => void;
}

export class TokenRatesController extends BaseController<ITokenRatesControllerConfig, ITokenRatesControllerState> {
  private conversionInterval: number;

  constructor({ config, state, onPreferencesStateChange, onNetworkStateChange, onTokensStateChange }: TokenRatesControllerOptions) {
    super({ config, state });
    this.defaultState = {
      ...this.defaultState,
      contractExchangeRates: {},
    };
    this.initialize();

    onPreferencesStateChange((preferencesState) => {
      const { selectedAddress } = preferencesState;
      this.configure({ selectedAddress });
    });

    onNetworkStateChange((networkState) => {
      const { chainId, ticker } = networkState.providerConfig;
      this.configure({ chainId, nativeCurrency: ticker });
    });

    onTokensStateChange((tokensState) => {
      const { tokens } = tokensState;
      const currentUserTokens = tokens[this.config.selectedAddress];
      if (currentUserTokens?.length > 0 && this.config.tokens !== tokens[this.config.selectedAddress]) {
        this.configure({ tokens: tokens[this.config.selectedAddress] });
        this.updateExchangeRates();
      }
    });
  }

  /**
   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
   * previous interval is clear and a new one is created.
   */
  public scheduleConversionInterval(): void {
    if (this.conversionInterval) {
      window.clearInterval(this.conversionInterval);
    }
    this.conversionInterval = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.updateExchangeRates();
      }
    }, this.config.pollInterval);
  }

  public async updateExchangeRates() {
    const chainCodes = COINGECKO_PLATFORMS_CHAIN_CODE_MAP[this.config.chainId];
    let newContractExchangeRates: ContractExchangeRates = {};
    if (!chainCodes) {
      log.info(`ChainId ${this.config.chainId} not supported by coingecko`);
      this.config.tokens.forEach((token) => {
        newContractExchangeRates[token.tokenAddress] = undefined;
      });
    } else {
      newContractExchangeRates = await this.fetchExchangeRates(this.config.nativeCurrency, chainCodes);
    }
    this.update({ contractExchangeRates: newContractExchangeRates });
  }

  private async fetchExchangeRates(nativeCurrency: string, chainCodes: { platform: string; currency: string }): Promise<ContractExchangeRates> {
    const contractAddresses = this.config.tokens.map((token) => token.tokenAddress);

    const isNativeCurrencySupported = COINGECKO_SUPPORTED_CURRENCIES.has(nativeCurrency.toLowerCase());
    if (isNativeCurrencySupported) {
      const response = await get<CoinGeckoResponse>(
        `${this.config.api}/simple/token_price/${chainCodes.platform}?contract_addresses=${contractAddresses.join(
          ","
        )}&vs_currencies=${nativeCurrency.toLowerCase()}&include_market_cap=false&include_24hr_vol=false&include_24hr_change=false&include_last_updated_at=false`
      );
      const newContractExchangeRates: ContractExchangeRates = {};
      Object.keys(response).forEach((contractAddress) => {
        newContractExchangeRates[contractAddress] = response[contractAddress][nativeCurrency.toLowerCase()] || 0;
      });
      return newContractExchangeRates;
    }
    const [response, currencyResponse] = await Promise.all([
      get<CoinGeckoResponse>(
        `${this.config.api}/simple/token_price/${chainCodes.platform}?contract_addresses=${contractAddresses.join(
          ","
        )}&vs_currencies=${DEFAULT_CURRENCY}&include_market_cap=false&include_24hr_vol=false&include_24hr_change=false&include_last_updated_at=false`
      ),
      get<Record<string, string>>(`${this.config.currencyApi}/currency?fsym=${nativeCurrency.toUpperCase()}&tsyms=${DEFAULT_CURRENCY.toUpperCase()}`),
    ]);
    const newContractExchangeRates: ContractExchangeRates = {};
    Object.keys(response).forEach((contractAddress) => {
      newContractExchangeRates[contractAddress] =
        response[contractAddress][DEFAULT_CURRENCY] * Number.parseFloat(currencyResponse[DEFAULT_CURRENCY]) || 0;
    });
    return newContractExchangeRates;
  }
}
