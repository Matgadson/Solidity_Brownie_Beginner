import { BaseController, PreferencesState } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import { BrowserProvider, Contract, toQuantity } from "ethers";
import log from "loglevel";

import NetworkController from "../Network/NetworkController";
import PreferencesController from "../Preferences/PreferencesController";
import { singleBalanceCheckerAbi } from "../utils/abis";
import { ETHERSCAN_SUPPORTED_CHAINS } from "../utils/constants";
import { SINGLE_CALL_BALANCES_ADDRESSES } from "../utils/contractAddresses";
import { idleTimeTracker, toChecksumAddressByChainId } from "../utils/helpers";
import { CustomTokenInfo, EthereumNetworkState, ExtendedAddressPreferences } from "../utils/interfaces";
import { TokensControllerConfig, TokensControllerState } from "./ITokensController";
import { TokenHandler } from "./TokenHandler";

export interface ITokensControllerOptions {
  config?: Partial<TokensControllerConfig>;
  state?: Partial<TokensControllerState>;
  provider: SafeEventEmitterProvider;
  getCustomTokens?: PreferencesController["getCustomTokens"];
  getEtherScanTokens: PreferencesController["getEtherScanTokens"];
  getProviderConfig: NetworkController["getProviderConfig"];
  onPreferencesStateChange: (listener: (preferencesState: PreferencesState<ExtendedAddressPreferences>) => void) => void;
  onNetworkStateChange: (listener: (networkState: EthereumNetworkState) => void) => void;
}

function getObjectFromArrayBasedonKey(oldArray: CustomTokenInfo[], key: string) {
  return oldArray.reduce((acc: Record<string, CustomTokenInfo>, x) => {
    const xkey = x[key as keyof CustomTokenInfo];
    if (typeof xkey === "boolean") return acc;
    acc[xkey] = x;
    return acc;
  }, {});
}

const mergeTokenArrays = (oldArray: CustomTokenInfo[], newArray: CustomTokenInfo[]): CustomTokenInfo[] => {
  const oldMap = getObjectFromArrayBasedonKey(oldArray || [], "tokenAddress");
  const newMap = getObjectFromArrayBasedonKey(newArray || [], "tokenAddress");
  const finalArr = newArray;
  Object.keys(oldMap).forEach((x) => {
    if (!newMap[x] && oldMap[x].isEtherScan) finalArr.push(oldMap[x]);
  });
  return finalArr;
};

const DEFAULT_INTERVAL = 180 * 1000;

export class TokensController extends BaseController<TokensControllerConfig, TokensControllerState> {
  name = "TokensController";

  private provider: SafeEventEmitterProvider;

  private ethersProvider: BrowserProvider;

  private _timer: number;

  private getProviderConfig: NetworkController["getProviderConfig"];

  private getCustomTokens: PreferencesController["getCustomTokens"];

  private getEtherScanTokens: PreferencesController["getEtherScanTokens"];

  constructor({
    config,
    state,
    provider,
    getCustomTokens,
    getEtherScanTokens,
    getProviderConfig,
    onPreferencesStateChange,
    onNetworkStateChange,
  }: ITokensControllerOptions) {
    super({ config, state });

    this.provider = provider;
    this.ethersProvider = new BrowserProvider(this.provider, "any");

    this.getCustomTokens = getCustomTokens;
    this.getEtherScanTokens = getEtherScanTokens;
    this.getProviderConfig = getProviderConfig;

    this.defaultConfig = {
      interval: DEFAULT_INTERVAL,
      selectedAddress: "",
      chainId: "",
    };

    this.defaultState = {
      tokens: {},
    };
    this.initialize();

    onPreferencesStateChange((preferencesState) => {
      if (preferencesState.selectedAddress !== this.config.selectedAddress) {
        this.configure({ selectedAddress: preferencesState.selectedAddress });
        this.restartTokenDetection();
      }
    });

    onNetworkStateChange((networkState) => {
      const { chainId } = networkState.providerConfig;
      if (chainId !== this.config.chainId) {
        this.configure({ chainId });
        this.restartTokenDetection();
      }
    });
  }

  get userSelectedAddress(): string {
    return this.config.selectedAddress;
  }

  get userTokens() {
    if (!this.userSelectedAddress) return [];
    return this.state.tokens[this.userSelectedAddress] ?? [];
  }

  get interval(): number {
    return this.config.interval;
  }

  set interval(interval: number) {
    if (this._timer) window.clearInterval(this._timer);
    if (!interval) {
      return;
    }
    this._timer = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.detectNewTokens();
        this.refreshTokenBalances();
      }
    }, interval);
  }

  public startTokenDetection(selectedAddress: string) {
    this.configure({ selectedAddress });
    this.restartTokenDetection();
  }

  /**
   * Restart token detection polling period and call detectNewTokens
   * in case of address change or user session initialization.
   *
   */
  public restartTokenDetection() {
    if (!this.userSelectedAddress) {
      return;
    }
    this.detectNewTokens();
    this.refreshTokenBalances();
    this.config.interval = DEFAULT_INTERVAL;
  }

  public detectNewTokens() {
    const userAddress = this.userSelectedAddress;
    if (!userAddress) return;
    const currentChainId = this.config.chainId;
    const tokens: CustomTokenInfo[] = []; // object[]
    if (!currentChainId) {
      this.update({ tokens: { [userAddress]: [...tokens] } });
      return;
    }

    const networkConfig = this.getProviderConfig();

    if (networkConfig?.isErc20 && networkConfig?.tokenAddress) {
      tokens.push({
        tokenAddress: networkConfig.tokenAddress,
        name: networkConfig.tickerName,
        logo: networkConfig.logo,
        erc20: true,
        symbol: networkConfig.ticker,
        decimals: "18",
        chainId: currentChainId,
      });
    }
    if (this.getCustomTokens) {
      const customTokens = this.getCustomTokens(userAddress);
      tokens.push(
        ...customTokens.reduce((acc, x) => {
          if (x.network === currentChainId)
            acc.push({
              tokenAddress: x.token_address,
              name: x.token_name,
              logo: "eth.svg",
              erc20: true,
              symbol: x.token_symbol,
              decimals: x.decimals,
              balance: "",
              customTokenId: x.id.toString(),
              chainId: x.network,
            });
          return acc;
        }, [] as CustomTokenInfo[])
      );
    }
    this.update({ tokens: { [userAddress]: [...tokens] } });
  }

  async refreshTokenBalances() {
    const userAddress = this.userSelectedAddress;
    if (userAddress === "") return;
    const oldTokens = [...this.userTokens];
    const tokenAddresses = oldTokens.map((x) => x.tokenAddress);
    const nonZeroTokens: CustomTokenInfo[] = [];
    try {
      const currentChainId = this.config.chainId;
      if (ETHERSCAN_SUPPORTED_CHAINS.includes(currentChainId)) {
        const etherscanBalances = await this.getEtherScanTokens(userAddress, currentChainId);
        nonZeroTokens.push(...etherscanBalances);
      }
      if (tokenAddresses.length > 0) {
        const currentSingleCallAddress = SINGLE_CALL_BALANCES_ADDRESSES[currentChainId];
        if (currentSingleCallAddress) {
          const ethContract = new Contract(currentSingleCallAddress, singleBalanceCheckerAbi, this.ethersProvider);
          const result = await ethContract.balances([userAddress], tokenAddresses);
          tokenAddresses.forEach((_, index) => {
            const balance = toQuantity(result[index]);
            if (balance && balance !== "0x0") {
              nonZeroTokens.push({ ...oldTokens[index], balance, chainId: currentChainId });
            }
          });
        } else {
          this.getTokenBalancesUsingHandler(oldTokens);
        }
      }
    } catch (error) {
      log.error(error, "unable to fetch token balances using single call balance address");
      this.getTokenBalancesUsingHandler(oldTokens);
    } finally {
      this.update({ tokens: { [userAddress]: nonZeroTokens } });
    }
  }

  async getTokenBalancesUsingHandler(customTokens: CustomTokenInfo[]) {
    if (!this.userSelectedAddress) return;
    const currentNetworkTokens = customTokens;
    const promiseSettledResult = await Promise.allSettled(
      currentNetworkTokens.map(async (x) => {
        try {
          const tokenInstance = new TokenHandler({
            address: x.tokenAddress,
            decimals: Number.parseInt(x.decimals),
            name: x.name,
            symbol: x.symbol,
            provider: this.ethersProvider,
          });
          const balance = await tokenInstance.getUserBalance(this.userSelectedAddress);
          return {
            decimals: tokenInstance.decimals.toString(),
            erc20: true,
            logo: x.logo || "eth.svg",
            name: tokenInstance.name,
            symbol: tokenInstance.symbol,
            tokenAddress: toChecksumAddressByChainId(tokenInstance.address, x.chainId),
            balance: `0x${balance}`,
            customTokenId: x.customTokenId,
            network: x.chainId,
            chainId: x.chainId,
          } as CustomTokenInfo;
        } catch (error) {
          log.warn("Invalid contract address while fetching", error);
          return undefined;
        }
      })
    );
    const nonZeroTokens = promiseSettledResult
      .filter((x) => x.status === "fulfilled")
      .map((x) => (x as PromiseFulfilledResult<CustomTokenInfo>).value);

    this.update({ tokens: { [this.userSelectedAddress]: mergeTokenArrays(this.userTokens, nonZeroTokens) } });
  }
}
