import { BaseController, PreferencesState } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import { BrowserProvider } from "ethers";
import { merge } from "lodash";
import log from "loglevel";

import PreferencesController from "../Preferences/PreferencesController";
import { SIMPLEHASH_SUPPORTED_CHAINS } from "../utils/constants";
import { idleTimeTracker } from "../utils/helpers";
import { CustomNftInfo, CustomNftItemInfo, EthereumNetworkState, ExtendedAddressPreferences } from "../utils/interfaces";
import { NftsControllerConfig, NftsControllerState } from "./INftsController";
import { NftHandler } from "./NftHandler";

export interface INftsControllerOptions {
  config?: Partial<NftsControllerConfig>;
  state?: Partial<NftsControllerState>;
  provider: SafeEventEmitterProvider;
  getCustomNfts?: PreferencesController["getCustomNfts"];
  getSimpleHashNfts: PreferencesController["getSimpleHashNfts"];
  onPreferencesStateChange: (listener: (preferencesState: PreferencesState<ExtendedAddressPreferences>) => void) => void;
  onNetworkStateChange: (listener: (networkState: EthereumNetworkState) => void) => void;
}

const DEFAULT_INTERVAL = 180 * 1000;

export class NftsController extends BaseController<NftsControllerConfig, NftsControllerState> {
  name = "NftsController";

  private provider: SafeEventEmitterProvider;

  private ethersProvider: BrowserProvider;

  private _timer: number;

  private getCustomNfts: PreferencesController["getCustomNfts"];

  private getSimpleHashNfts: PreferencesController["getSimpleHashNfts"];

  constructor({ config, state, provider, getCustomNfts, getSimpleHashNfts, onPreferencesStateChange, onNetworkStateChange }: INftsControllerOptions) {
    super({ config, state });

    this.provider = provider;
    this.ethersProvider = new BrowserProvider(this.provider, "any");

    this.getCustomNfts = getCustomNfts;
    this.getSimpleHashNfts = getSimpleHashNfts;

    this.defaultConfig = {
      interval: DEFAULT_INTERVAL,
      selectedAddress: "",
      chainId: "",
    };

    this.defaultState = {
      nfts: {},
    };
    this.initialize();
    onPreferencesStateChange((preferencesState) => {
      if (preferencesState.selectedAddress !== this.config.selectedAddress) {
        this.configure({ selectedAddress: preferencesState.selectedAddress });
        this.restartNftDetection();
      }
    });

    onNetworkStateChange((networkState) => {
      const { chainId } = networkState.providerConfig;
      if (chainId !== this.config.chainId) {
        this.configure({ chainId });
        this.restartNftDetection();
      }
    });
  }

  get userSelectedAddress(): string {
    return this.config.selectedAddress;
  }

  get userNfts() {
    if (!this.userSelectedAddress) return [];
    return this.state.nfts[this.userSelectedAddress] ?? [];
  }

  get interval(): number {
    return this.config.interval;
  }

  set interval(interval: number) {
    if (this._timer) window.clearInterval(this._timer);
    if (!interval) {
      return;
    }
    this._timer = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.detectNewNfts();
        this.refreshNftBalances();
      }
    }, interval);
  }

  public startNftDetection(selectedAddress: string) {
    this.configure({ selectedAddress });
    this.restartNftDetection();
  }

  /**
   * Restart nft detection polling period and call detectNewNfts
   * in case of address change or user session initialization.
   *
   */
  public restartNftDetection() {
    if (!this.userSelectedAddress) {
      return;
    }
    this.detectNewNfts();
    this.refreshNftBalances();
    this.config.interval = DEFAULT_INTERVAL;
  }

  public detectNewNfts() {
    const userAddress = this.userSelectedAddress;
    if (!userAddress) return;
    const currentChainId = this.config.chainId;
    const nftsToDetect: CustomNftInfo[] = []; // object[]
    if (!currentChainId) {
      this.update({ nfts: { [userAddress]: [...nftsToDetect] } });
      return;
    }

    if (this.getCustomNfts) {
      const customNfts = this.getCustomNfts(userAddress);

      const reducedNfts = customNfts.reduce(
        (acc, x) => {
          // first aggregate by contract address
          if (x.network === currentChainId) {
            const newAsset: CustomNftItemInfo = {
              description: "",
              image: "",
              name: "",
              tokenBalance: "",
              tokenId: x.nft_id,
              customNftId: x.id.toString(),
            };
            if (acc[x.nft_address]) {
              acc[x.nft_address].assets.push(newAsset);
            } else {
              const objToPush: CustomNftInfo = {
                assets: [newAsset],
                chainId: x.network,
                contractAddress: x.nft_address,
                contractName: "",
                contractSymbol: "",
                contractImage: "",
                nftStandard: x.nft_contract_standard,
                contractDescription: "",
              } as CustomNftInfo;
              acc[x.nft_address] = objToPush;
            }
          }
          return acc;
        },
        {} as Record<string, CustomNftInfo>
      );
      nftsToDetect.push(...Object.values(reducedNfts));
    }
    this.update({ nfts: { [userAddress]: [...nftsToDetect] } });
  }

  async refreshNftBalances() {
    const userAddress = this.userSelectedAddress;
    if (userAddress === "") return;
    const oldNfts = [...this.userNfts];
    const nonZeroNfts: CustomNftInfo[] = [];
    try {
      const currentChainId = this.config.chainId;
      if (SIMPLEHASH_SUPPORTED_CHAINS.includes(currentChainId)) {
        const simpleHashBalances = await this.getSimpleHashNfts(userAddress, currentChainId);
        nonZeroNfts.push(...simpleHashBalances);
        this.update({ nfts: { [userAddress]: nonZeroNfts } });
      }
      if (oldNfts.length > 0) {
        this.getNftBalancesUsingHandler(oldNfts);
      }
    } catch (error) {
      log.error(error, "unable to fetch nft balances");
    }
  }

  async getNftBalancesUsingHandler(customNfts: CustomNftInfo[]) {
    if (!this.userSelectedAddress) return;
    const userAddress = this.userSelectedAddress;
    const currentNetworkNfts = customNfts;
    const promiseSettledResult = await Promise.allSettled(
      currentNetworkNfts.map(async (x) => {
        try {
          const tokenInstance = new NftHandler({
            ...x,
            provider: this.ethersProvider,
          });
          const contractData = await tokenInstance.getContractMetadata();
          const assetData = await Promise.allSettled(x.assets.map((y) => tokenInstance.getNftMetadata(userAddress, y)));
          return {
            ...contractData,
            assets: assetData.filter((z) => z.status === "fulfilled").map((z) => (z as PromiseFulfilledResult<CustomNftItemInfo>).value),
          } as CustomNftInfo;
        } catch (error) {
          log.warn("Invalid contract address while fetching", error);
          return undefined;
        }
      })
    );
    const nonZeroTokens = promiseSettledResult.filter((x) => x.status === "fulfilled").map((x) => (x as PromiseFulfilledResult<CustomNftInfo>).value);

    this.update({ nfts: { [userAddress]: merge(this.userNfts, nonZeroTokens) } });
  }
}
