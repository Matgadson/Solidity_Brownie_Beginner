import { get } from "@toruslabs/http-helpers";
import { BrowserProvider, Contract } from "ethers";
import log from "loglevel";

import { erc721Abi, erc1155Abi } from "../utils/abis";
import { CONTRACT_TYPE_ERC721, CONTRACT_TYPE_ERC1155, ERC721_INTERFACE_ID, ERC1155_INTERFACE_ID, OLD_ERC721_LIST } from "../utils/constants";
import { sanitizeNftMetdataUrl } from "../utils/helpers";
import { CustomNftInfo, CustomNftItemInfo, NftStandardType } from "../utils/interfaces";

interface INftOptions {
  contractAddress: string;
  contractName?: string;
  contractSymbol?: string;
  contractImage?: string;
  contractSupply?: string;
  contractFallbackLogo?: string;
  nftStandard?: "erc721" | "erc1155";
  contractDescription?: string;
  chainId: string;
  provider: BrowserProvider;
}

export class NftHandler {
  public contractAddress: string;

  public contractName: string;

  public contractSymbol: string;

  public contractImage: string;

  public contractSupply?: string;

  public contractFallbackLogo?: string;

  public nftStandard: "erc721" | "erc1155";

  public contractDescription?: string;

  public chainId: string;

  public provider: BrowserProvider;

  public isSpecial?: boolean;

  constructor({
    chainId,
    contractAddress,
    contractImage,
    contractName,
    contractSymbol,
    nftStandard,
    provider,
    contractDescription,
    contractFallbackLogo,
    contractSupply,
  }: INftOptions) {
    this.chainId = chainId;
    this.contractAddress = contractAddress;
    this.contractImage = contractImage;
    this.contractName = contractName;
    this.contractSymbol = contractSymbol;
    this.nftStandard = nftStandard;
    this.provider = provider;
    this.contractDescription = contractDescription;
    this.contractFallbackLogo = contractFallbackLogo;
    this.contractSupply = contractSupply;
  }

  async getNftMetadata(userAddress: string, tokenInfo: Partial<CustomNftItemInfo>): Promise<CustomNftItemInfo> {
    const returnNftItem: CustomNftItemInfo = { description: "", image: "", name: "", tokenBalance: "", tokenId: "", decimals: "1", ...tokenInfo };

    const [tokenURI, balance] = await Promise.all([
      this.getCollectibleTokenURI(returnNftItem.tokenId, this.nftStandard),
      !returnNftItem.tokenBalance ? this.fetchNftBalance(userAddress, returnNftItem.tokenId) : Promise.resolve("0"),
    ]);
    returnNftItem.tokenBalance = returnNftItem.tokenBalance || balance;
    // some people put full json object in uri
    try {
      const object = JSON.parse(tokenURI);
      returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);
      returnNftItem.name = returnNftItem.name || object.name;
      returnNftItem.description = returnNftItem.description || object.description;
      returnNftItem.decimals = returnNftItem.decimals || object.decimals;
    } catch (error) {
      log.warn("Token uri is not a valid json object", error);
    }
    const finalTokenMetaUri = sanitizeNftMetdataUrl(tokenURI);
    try {
      if (!returnNftItem.description || !returnNftItem.image || !returnNftItem.name) {
        // this call might fail, if metadata url available in smart contract is not reachable
        const object = await get<{ name: string; description: string; image: string; decimals?: string }>(finalTokenMetaUri);
        returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);
        returnNftItem.name = returnNftItem.name || object.name;
        returnNftItem.description = returnNftItem.description || object.description;
        returnNftItem.decimals = returnNftItem.decimals || object.decimals;
      }
    } catch (error) {
      log.error("Failed to fetch nft metadata", error);
    }
    return returnNftItem;
  }

  async getContractMetadata(): Promise<Omit<CustomNftInfo, "assets">> {
    const returnNft: Omit<CustomNftInfo, "assets"> = {
      chainId: this.chainId,
      contractAddress: this.contractAddress,
      contractName: this.contractName,
      contractSymbol: this.contractSymbol,
      nftStandard: this.nftStandard,
      contractImage: this.contractImage,
      contractDescription: this.contractDescription,
      contractFallbackLogo: this.contractFallbackLogo,
      contractSupply: this.contractSupply,
    };
    if (!this.nftStandard) {
      const { standard, isSpecial } = await this.checkNftStandard();
      returnNft.nftStandard = standard;
      this.nftStandard = standard;
      this.isSpecial = isSpecial;
    }
    if (!this.contractName || !this.contractSymbol || !this.contractDescription) {
      const abi = this.nftStandard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
      const contract = new Contract(this.contractAddress, abi, this.provider);
      const [name, symbol] = await Promise.all([contract.name(), contract.symbol()]);
      returnNft.contractName = name;
      returnNft.contractSymbol = symbol;
      if (!this.contractName) this.contractName = name;
      if (!this.contractSymbol) this.contractSymbol = symbol;
    }

    return returnNft;
  }

  async fetchNftBalance(userAddress: string, tokenId: string): Promise<string> {
    const { standard } = await this.checkNftStandard();
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    if (standard === CONTRACT_TYPE_ERC1155) {
      const balance = await contract.balanceOf(userAddress, tokenId);
      return balance;
    }
    let owner = "";
    try {
      owner = await contract.ownerOf(tokenId);
    } catch {
      throw new Error("Token id doesn't exists");
    }
    if (owner.toLowerCase() === userAddress.toLowerCase()) {
      return "1";
    }
    return "0";
  }

  private async checkNftStandard(): Promise<{ isSpecial: boolean; standard: NftStandardType }> {
    // For Cryptokitties
    if (this.nftStandard && this.isSpecial !== undefined) return;
    if (Object.prototype.hasOwnProperty.call(OLD_ERC721_LIST, this.contractAddress.toLowerCase())) {
      this.nftStandard = CONTRACT_TYPE_ERC721;
      this.isSpecial = true;
      return { standard: CONTRACT_TYPE_ERC721, isSpecial: true };
    }
    const isErc721 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC721, ERC721_INTERFACE_ID);
    if (isErc721) {
      this.nftStandard = CONTRACT_TYPE_ERC721;
      this.isSpecial = false;
      return { standard: CONTRACT_TYPE_ERC721, isSpecial: false };
    }
    const isErc1155 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC1155, ERC1155_INTERFACE_ID);
    if (isErc1155) {
      this.nftStandard = CONTRACT_TYPE_ERC1155;
      this.isSpecial = false;
      return { standard: CONTRACT_TYPE_ERC1155, isSpecial: false };
    }

    throw new Error("Unsupported nft standard");
  }

  private async contractSupportsInterface(standard: NftStandardType, interfaceId: string): Promise<boolean> {
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    return contract.supportsInterface(interfaceId);
  }

  private async getCollectibleTokenURI(tokenId: string, standard: NftStandardType = CONTRACT_TYPE_ERC721): Promise<string> {
    const method = standard === CONTRACT_TYPE_ERC721 ? "tokenURI" : "uri";
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    return contract[method](tokenId);
  }
}
