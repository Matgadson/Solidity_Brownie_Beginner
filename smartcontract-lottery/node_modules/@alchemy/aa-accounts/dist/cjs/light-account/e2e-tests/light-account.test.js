"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const accounts_1 = require("viem/accounts");
const chains_1 = require("viem/chains");
const index_js_1 = require("../../index.js");
const constants_js_1 = require("./constants.js");
const chain = chains_1.sepolia;
aa_core_1.Logger.setLogLevel(aa_core_1.LogLevel.DEBUG);
describe("Light Account Tests", () => {
    const owner = aa_core_1.LocalAccountSigner.mnemonicToAccountSigner(constants_js_1.LIGHT_ACCOUNT_OWNER_MNEMONIC);
    const undeployedOwner = aa_core_1.LocalAccountSigner.mnemonicToAccountSigner(constants_js_1.UNDEPLOYED_OWNER_MNEMONIC);
    it("should successfully get counterfactual address", async () => {
        const provider = givenConnectedProvider({ owner, chain });
        expect(await provider.getAddress()).toMatchInlineSnapshot('"0x1a3a89cd46f124EF40848966c2D7074a575dbC27"');
    });
    it("should sign typed data successfully", async () => {
        const provider = givenConnectedProvider({ owner, chain });
        const typedData = {
            types: {
                Request: [{ name: "hello", type: "string" }],
            },
            primaryType: "Request",
            message: {
                hello: "world",
            },
        };
        expect(await provider.signTypedData(typedData)).toBe(await owner.signTypedData(typedData));
    });
    it("should sign message successfully", async () => {
        const provider = givenConnectedProvider({ owner, chain });
        expect(await provider.signMessage("test")).toBe(await owner.signMessage("test"));
    });
    it("should sign typed data with 6492 successfully for undeployed account", async () => {
        const undeployedProvider = givenConnectedProvider({
            owner: undeployedOwner,
            chain,
        });
        const typedData = {
            types: {
                Request: [{ name: "hello", type: "string" }],
            },
            primaryType: "Request",
            message: {
                hello: "world",
            },
        };
        expect(await undeployedProvider.signTypedDataWith6492(typedData)).toMatchInlineSnapshot('"0x00000000000000000000000000000055c0b4fa41dde26a74435ff03692292fbd000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000445fbfb9cf000000000000000000000000ef9d7530d16df66481adf291dc9a12b44c7f7df00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041591a9422219a5f2bc87ee24a82a6d5ef9674bf7408a2a289984de258466d148e75efb65b487ffbfcb061b268b1b667d8d7d4eac2c3d9d2d0a52d49c891be567c1c000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492"');
    });
    it("should sign message with 6492 successfully for undeployed account", async () => {
        const undeployedProvider = givenConnectedProvider({
            owner: undeployedOwner,
            chain,
        });
        expect(await undeployedProvider.signMessageWith6492("test")).toMatchInlineSnapshot('"0x00000000000000000000000000000055c0b4fa41dde26a74435ff03692292fbd000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000445fbfb9cf000000000000000000000000ef9d7530d16df66481adf291dc9a12b44c7f7df00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041be34ecce63c5248d5cda407e7da319be3c861e6e2c5d30c9630cd35dcb55e56205c482503552883923f79e751ea3671cbb84d65b18af33cd3034aeb7d529da9a1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492"');
    });
    it("should execute successfully", async () => {
        const provider = givenConnectedProvider({ owner, chain });
        const result = await provider.sendUserOperation({
            target: await provider.getAddress(),
            data: "0x",
        });
        const txnHash = provider.waitForUserOperationTransaction(result.hash);
        await expect(txnHash).resolves.not.toThrowError();
    }, 100000);
    it("should fail to execute if account address is not deployed and not correct", async () => {
        const accountAddress = "0xc33AbD9621834CA7c6Fc9f9CC3c47b9c17B03f9F";
        const newProvider = givenConnectedProvider({
            owner,
            chain,
            accountAddress,
        });
        const result = newProvider.sendUserOperation({
            target: await newProvider.getAddress(),
            data: "0x",
        });
        await expect(result).rejects.toThrowError();
    });
    it("should get counterfactual for undeployed account", async () => {
        const owner = aa_core_1.LocalAccountSigner.privateKeyToAccountSigner((0, accounts_1.generatePrivateKey)());
        const provider = givenConnectedProvider({ owner, chain });
        const address = provider.getAddress();
        await expect(address).resolves.not.toThrowError();
        expect((0, viem_1.isAddress)(await address)).toBe(true);
    });
    it("should get owner successfully", async () => {
        const provider = givenConnectedProvider({ owner, chain });
        expect(await provider.account.getOwnerAddress()).toMatchInlineSnapshot('"0x65eaA2AfDF6c97295bA44C458abb00FebFB3a5FA"');
        expect(await provider.account.getOwnerAddress()).toBe(await owner.getAddress());
    });
    it("should transfer ownership successfully", async () => {
        const provider = givenConnectedProvider({
            owner,
            chain,
        });
        const throwawayOwner = aa_core_1.LocalAccountSigner.privateKeyToAccountSigner((0, accounts_1.generatePrivateKey)());
        const throwawayProvider = givenConnectedProvider({
            owner: throwawayOwner,
            chain,
        });
        const oldOwner = await throwawayOwner.getAddress();
        await provider.sendTransaction({
            from: await provider.getAddress(),
            to: await throwawayProvider.getAddress(),
            data: "0x",
            value: (0, viem_1.toHex)(1000000000000000n),
        });
        const newThrowawayOwner = aa_core_1.LocalAccountSigner.privateKeyToAccountSigner((0, accounts_1.generatePrivateKey)());
        await index_js_1.LightSmartContractAccount.transferOwnership(throwawayProvider, newThrowawayOwner, true);
        const newOwnerViaProvider = await throwawayProvider.account.getOwnerAddress();
        const newOwner = await newThrowawayOwner.getAddress();
        expect(newOwnerViaProvider).not.toBe(oldOwner);
        expect(newOwnerViaProvider).toBe(newOwner);
    }, 100000);
});
const givenConnectedProvider = ({ owner, chain, accountAddress, feeOptions, }) => {
    const provider = (0, index_js_1.createLightAccountProvider)({
        rpcProvider: `${chain.rpcUrls.alchemy.http[0]}/${constants_js_1.API_KEY}`,
        chain,
        owner,
        accountAddress,
        opts: {
            feeOptions,
            txMaxRetries: 100,
        },
    });
    return provider;
};
//# sourceMappingURL=light-account.test.js.map